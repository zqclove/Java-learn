# 概述

​	我们知道，计算机处理器的运算速度与其他组件的速度差距是很大的，大部分时间都消耗在磁盘IO、网络通信与数据库访问上。为了充分利用处理器资源，一些“残忍”的操作系统设计人员就想出了并发和并行的手段去“压榨”处理器。

​	对于服务端来说，一般需要同时对多个客户提供服务，这是一种具体的并发场景。衡量一个服务端性能的好坏，**每秒事务处理数（Transactions Per Second，TPS）**是重要指标之一，它代表每秒内服务端平均能响应的请求总数。

# 硬件的效率与一致性

​	由于现代计算机系统中的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都会在内存和处理器之间加入高速缓存（读写速度更快），将运算需要的数据复制到该缓存中，运算结束后再将缓存同步回内存中。

​	这种引入高速缓存在单处理器系统中没有什么问题，但如果在多处理器环境下（每个处理器都有自己的高速缓存），两个以上的处理器如果对同一内存区域操作时，那就会发生 **缓存一致性问题**。而为了解决这个问题，就需要在读写时根据某种协议[^注2.1.1]来操作。

​	因为有着 Java内存模型的知识，发现这种物理机器的内存模型与之非常相似，同样有着主内存和工作内存（高速缓存）。但需要注意的是，这种内存模型是对内存或高速缓存进行读写的抽象过程，不同架构的物理机器可以有不同的内存模型。

​	还有一点是，为了使处理器的运算单元能够被充分利用，处理器可能会对输入代码进行**乱序执行优化**，在计算之后将乱序执行的结果重组，保证结果与顺序执行的结果一致，但并不保证程序各个语句计算的先后顺序与代码中的顺序一致，因此如果存在一个计算任务依赖另一个计算任务的**中间结果**，那么其顺序性并不能靠代码的先后顺序来保证。与此类似，Java的即时编译中也有**指令重排序优化**。



​	**个人理解**：关于处理器的乱序执行优化，这种优化只能保证一个计算任务的最终结果是正确的，但如果有依赖关系，仅靠代码顺序是不能保证其计算的正确性，所以需要依靠进程通信机制确保其这种依赖关系的计算能被处理器感知。需要注意的是，依赖的是另一个计算任务的中间结果，如果是依赖最终结果那么正确性是否就能保证呢？如果处理器一次只执行一个计算任务，那应该是可以保证，但执行多个的话可能就需要同步机制。

[^注2.1.1]:这类协议有MSI、MESI、MOSI等

# Java内存模型

​	Java语言的 “Write One，Run Everywhere”的思想具化就是 Java内存模型，实现该模型的目的是为了屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java程序在各种平台上都能达到一致的内存访问效果。这就不同于一些主流程序语言（C和C++等）直接使用物理硬件和操作系统的内存模型。详细的 Java内存模型规范可以去查看**JSR-133**等。

## 主内存与工作内存

​	

# Java与线程



# Java与协程



# 参考资料

《深入理解Java虚拟机：JVM高级特性与最佳实践》（第三版）——周志明著



