# 运行时数据区

 [![img](https://camo.githubusercontent.com/397eed8a3eff96cc19cedbee1f20f100afaf6295/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67)](https://camo.githubusercontent.com/397eed8a3eff96cc19cedbee1f20f100afaf6295/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67) 



 [![img](https://camo.githubusercontent.com/397eed8a3eff96cc19cedbee1f20f100afaf6295/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67)](https://camo.githubusercontent.com/397eed8a3eff96cc19cedbee1f20f100afaf6295/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67) 



# 程序计数器

​	程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里 [1] ，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

​	由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯
一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

​	 “概念模型”这个词会经常被提及，它代表了所有虚拟机的统一外观，但各款具体的Java虚拟机并不一定要完全照着概念模型的定义来进行设计，可能会通过一些更高效率的等价方式去实现它。

# Java 虚拟机栈

​	每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

​	**局部变量表存放了编译期可知**的各种 Java 虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和**returnAddress类型**（指向了一条字节码指令的地址）。

​	这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，**其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。**请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。

 [![img](https://camo.githubusercontent.com/96d3e63fbdedc3e6af5f8365815898bef9799ea3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38343432353139662d306234642d343866342d383232392d3536663938343336336336392e706e67)](https://camo.githubusercontent.com/96d3e63fbdedc3e6af5f8365815898bef9799ea3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38343432353139662d306234642d343866342d383232392d3536663938343336336336392e706e67) 



可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：

```
java -Xss2M HackTheJava
```

该区域可能抛出以下异常：

- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

​	**HotSpot虚拟机的栈容量是不可以动态扩展的。**所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的。

# 本地方法栈

本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

 [![img](https://camo.githubusercontent.com/1d8a26c9cee39aa0d6f7e1a165b422f0fa0d4187/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36366136383939642d633662302d346134372d383536392d3964303866306261663836632e706e67)](https://camo.githubusercontent.com/1d8a26c9cee39aa0d6f7e1a165b422f0fa0d4187/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36366136383939642d633662302d346134372d383536392d3964303866306261663836632e706e67) 





# 堆

所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：

- 新生代（Young Generation）
- 老年代（Old Generation）

​	分代的区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个 Java虚拟机具体实现的固有内存布局，更不是《虚拟机规范》里对 Java堆的进一步细致划分。

​	堆不需要连续内存，但在逻辑上它应该被视为连续的。堆可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

```shell
java -Xms1M -Xmx2M HackTheJava
```



# 方法区

​	用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。

​	**对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。**

​	HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC  之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8  开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

​	方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。**元空间存储类的元信息（类型信息）**，**而静态变量和常量池等放入堆中。**



# 运行时常量池

​	运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

​	除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。



# 直接内存

​	直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分的内存也被频繁使用。

​	在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存（Java堆）和堆外内存（Native堆）来回拷贝数据。

​	显然，本机直接内存的分配不会受到 Java堆大小的限制。但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。

# HotSpot对象虚拟机探秘

***本章节来自深入理解Java虚拟机：JVM高级特性与最佳实践（第 3版）的 2.3节***

## 对象的创建

​	当 Java虚拟机遇到一条**字节码new指令 **时，首先将去检查这个**指令的参数是否能在常量池中定位到**一个**类的符号引用**，并且检查这个**符号引用代表的类是否已被加载、解析和初始化过**。如果没有，那必须先执行相应的[类加载过程](#类的加载过程)。

​	在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定见[对象的内存布局](#对象的内存布局)），为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。

**1.创建对象时的内存分配：**

​	假设 **Java堆中内存是绝对规整的**，所有**被使用过的内存都被放在一边**，**空闲的内存被放在另一边**，**中间放着一个指针作为分界点的指示器**，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“**指针碰撞”（Bump ThePointer）**。

​	但如果 **Java堆中的内存并不是规整的**，**已被使用的内存和空闲的内存相互交错在一起**，那就没有办法简单地进行指针碰撞了，虚拟机就必须**维护一个列表**，记录上哪些内存块是可用的，在**分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录**，这种分配方式称为**“空闲列表”（Free List）**。

​	选择哪种分配方式由Java堆是否规整决定，而 Java堆是否规整又由所采用的**垃圾收集器是否带有空间压缩整理（Compact）的能力决定**。因此，当使用**Serial、ParNew等带压缩整理过程的收集器**时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用**CMS这种基于清除（Sweep）算法的收集器**时，理论上就只能采用较为复杂的空闲列表来分配内存。（强调“理论上”是因为在CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作LinearAllocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指针碰撞方式来分配。）

​	对象分配还需要考虑另外一个问题：并发情况下的对象创建。解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用 **CAS** 配上 **失败重试** 的方式保证更新操作的原子性；另外一种是把内存分配按照线程划分在不同的空间中进行的，即每个线程在 Java堆中预先分配一小块内存，成为**本地线程分配缓冲**（Thread Local Allocation Buffer, TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区分配，**只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定**。虚拟机是否使用TLAB，可以通过 **-XX: +/-UseTLAB** 参数来设定。

**2.分配内存后的工作：**

​	内存分配完后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了TLAB，那么在该工作分配TLAB时顺便进行了。这步操作保证了对象的实例字段在 Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

​	接下来，Java虚拟机还要对对象进行必要的设置，例如这个**对象是哪个类的实例**、如何才能找到类的元数据信息、**对象的哈希码**（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。**这些信息存放在对象的对象头（Object Header）之中。**根据虚拟机当前**运行状态的不同**，如是否启用偏向锁等，**对象头会有不同的设置方式**。

​	此时，从虚拟机的角度上来看，对象的创建已经完成。但是从 Java程序角度来看，对象创建才刚刚开始——构造函数，即 Class文件中的 **\<init>()** 方法还没有执行，所有字段的值都默认为零，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说[^注1]，new指令之后会接着执行**\<init>()** 方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

​	在《深入理解Java虚拟机：JVM高级特性与最佳实践（第三版）》中，有HotSpot虚拟机字节码解释器（bytecodeInterpreter.cpp）中的代码片段。这个解释器实现很少有机会实际使用，大部分平台上都使用模板解释器；当代码通过即时编译器执行时差异就更大了。不过这段代码用于了解HotSpot的运作过程是没有什么问题的。（这里不贴出代码，如需请自行查找书籍）

### 自我理解

**虚拟机中对象创建的逻辑：**

1.对象的创建必然需要占用堆内存，虚拟机就需要为对象分配内存空间；

2.虚拟机为对象分配内存空间需要根据空闲内存的规整程度（即空闲与非空闲的内存是否完全按逻辑分开）决定使用哪种分配策略（是否规整由所采用垃圾收集器是否带有空间压缩整理（Compact）的能力决定）；

3.空闲内存绝对规整使用**“指针碰撞”（空闲内存与非空闲内存的分界器）**，反之使用**“空间列表”（记录哪些内存空间可用）**；

4.考虑并发的问题，有两种策略：一是使用 CAS 配上失败重试的方式保证操作原子性；二是通过为每个线程分配本地线程缓冲（TLAB，每个线程在堆中有自己的空间，不够再同步扩容）；

5.对象内存分配完成后需要将内存空间的值初始化为零，之后需要对对象进行比较配置，如对象头信息等。此时从虚拟机角度上对象已经创建完毕，但并未调用构造函数（\<init>() 方法并执行）。

[^注1]: 执行 \<init>() 方法由字节码流中new指令后面是否跟随 invokespecial 指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此

## 对象的内存布局

​	在HotSpot虚拟机里，对象在堆中的内存布局被分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

**1.对象头（Header）：**

​	HotSpot虚拟机对象的对象头包含两类信息。

​	第一类信息是**Mark Word**，用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特。

​	对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，**Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。**例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示：

| 存储内容                             | 标志位 | 状态                     |
| :----------------------------------- | :----- | :----------------------- |
| 对象哈希码、对象分代年龄             | 01     | 未锁定（上面例子的状态） |
| 指向锁记录的指针                     | 00     | 轻量级锁定               |
| 指向重量级锁的指针                   | 10     | 膨胀（重量级锁定）       |
| 空，不需要记录信息                   | 11     | GC标记                   |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向                   |

***注意：标志位为 01时，有两个状态，对象具体处于哪个状态由存储内容决定。***

​	第二类信息是**类型指针**，即对象指向它的类型元数据的指针，虚拟机通过该指针确定对象属于哪个类的实例。也有些虚拟机实现没有在对象数据上保留类型指针，而是通过其它方式查找对象的元数据信息。此外，如果对象是一个 Java数组，那么在对象头中还必须存在一块用于记录数组长度的数据（这也是为什么 Java一些集合类的最大容量是 MAX_ARRAY_SIZE），因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。

**2.示例数据（Instance Data）：**

​	该部分是**对象真正存储的有效信息**，即在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会收到虚拟机**分配策略参数（-XX: FieldsAllocationStyle）**和字段在 Java源码定义顺序的影响。

​	HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，**相同宽度的字段总是被分配到一起存放**，在**满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前**。如果HotSpot虚拟机的**+XX：CompactFields**参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。

**3.对齐填充（Padding）：**

​	对象的第三部分是**对齐填充**，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是**任何对象的大小都必须是8字节的整数倍**。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

## 对象的访问定位

​	Java程序代码在使用对象时，会通过虚拟机栈上的**reference数据**来操作堆上的具体对象。在《Java虚拟机规范》中并没有定义reference类型通过什么方式访问对象的具体位置，只是规定它是一个指向对象的引用。因此，对象的访问方式由虚拟机实现而定，主流的访问方式有使用**句柄**和**直接指针**。

​	如果使用**句柄访问**的话，Java堆中可能会划分出一块内存作为句柄池，**reference中存储的就是对象的句柄地址**，而**句柄中包含了对象到实例数据和类型数据的指针**，结构如下图所示：

![reference通过句柄访问对象数据](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\reference通过句柄访问对象数据.png)

​	如果使用**直接指针**访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，**reference中直接存储对象地址**。如果只是访问对象本身的话，就不需要多一次间接访问的开销，其结构如下图所示。

![reference通过直接指针访问对象数据](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\reference通过直接指针访问对象数据.png)

​	这两种对象访问方式各有优势：

- **使用句柄来访问**：最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的指向实例数据的指针，而reference本身不需要被修改。
- **使用直接指针来访问**：最大好处就是速度快，因为它节省了一次指针定位的开销，由于对象访问在 Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它主要使用第二种方式进行对象访问（有例外情况，如果使用了Shenandoah收集器的话也会有一次额外的转发，具体可参见[垃圾收集器与内存分配策略](Java虚拟机之垃圾收集器与内存分配策略)），但从整个软件开发的范围来看，在各种语言、框架中使用句柄来访问的情况也十分常见。



# OutOfMemoryError异常实战

暂