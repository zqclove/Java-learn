# Java虚拟机之类加载机制

# 概述

​	java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。这种动态组装应用的方式目前已广泛应用于Java程序之中，从最基础的Applet、JSP到相对复杂的OSGi技术，都依赖着Java语言运行期类加载才
得以诞生。

​	为了避免语言表达中可能产生的偏差，在正式开始本章以前，笔者先设立两个语言上的约定：

​	第一，在实际情况中，每个Class文件都有代表着Java语言中的一个类或接口的可能，后文中直接对“类型”的描述都同时蕴含着类和接口的可能性，而需要对类和接口分开描述的场景，笔者会特别指明；

​	第二，与前面介绍Class文件格式时的约定一致，本章所提到的“Class文件”也并非特指某个存在于具体磁盘中的文件，而应当是一串二进制字节流，无论其以何种形式存在，包括但不限于磁盘文件、网络、数据库、内存或者动态产生等。

# 类加载的时机

​	一个类型从被加载到虚拟机内存中开始到卸载为止，它的整个生命周期会经历**加载（loading）**、**验证（verification）**、**准备（preparation）**、**解析（resolution）**、**初始化（initialization）**、**使用（using）**和**卸载（unloading）**七个阶段。其中，验证、准备和解析三个部分统称为**连接（linking）**。

![类的生命周期](C:\Users\Administrator\Desktop\学习\java\Java-learn\img\类的生命周期.png)

​	如上图所示，**加载、验证、准备、初始化和卸载**这五个阶段的**顺序是确定的**，类型的加载过程必须按照这种顺序**开始**[^注2.1]，而**解析阶段不一样：它在某些情况下可以在初始化之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）**。

## 初始化时机

​	虚拟机规范中并**没有强制约束何时进行加载**，但是规范严格规定了**有且只有**下列六种情况**必须对类进行初始化**（加载、验证、准备都会随之发生）：

### 主动引用

- 遇到 `new`、`getstatic`、`putstatic`、`invokestatic`  这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 `new`  关键字实例化对象的时候；读取或设置一个类的静态字段（**被 final  修饰、已在编译期把结果放入常量池的静态字段除外**）的时候；以及调用一个类的静态方法的时候。
- 使用 **java.lang.reflect** 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
- 当使用 JDK 1.7 的动态语言支持时，如果一个 **java.lang.invoke.MethodHandle** 实例最后的解析结果为  **REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial** 四种类型的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；
- 当一个接口中定义了JDK 8新加入的默认方法（被`default`关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前初始化，

以上六种情形的行为被称为对一个类型的**主动引用**。

​	简而言之：在`new`、读取或设置静态字段（常量除外）、调用类的静态方法、反射调用、初始化类（先触发父类的初始化）、初始化主类（包含main（）方法）、有默认方法的接口的实现类初始化时，如果发现类（或接口）没有初始化，则需要先初始化类。



```java
public class InitializationTest {

    static {
        System.out.println("static");
    }

    public static void main(String[] args) {
        System.out.println("main");
    }
}
//主类在虚拟机启动时初始化。
```

### 被动引用

除主动引用外，所有引用类的方式都不会触发初始化，称为**被动引用**。被动引用的常见例子包括：

- **通过子类引用父类的静态字段**，不会导致**子类**初始化。

```java
System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
```

- **通过数组定义来引用类**，不会触发此类的初始化。**该过程会对数组类进行初始化**，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法（被public修饰的length属性和clone方法）。

```java
SuperClass[] sca = new SuperClass[10];
```

- **常量在编译阶段会存入调用类的常量池中**，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。（对于调用其它类的常量的类，都会转化为对自身常量池的引用，因此，这种调用产生的引用关系是不存在的。）

```java
System.out.println(ConstClass.HELLOWORLD);
```

> **Tip**：
>
> ​	接口的加载过程和类的加载过程有些不同。接口与类一样也有初始化过程，但类可以使用静态语句块，而接口不能使用静态语句块，但编译器仍然会为接口生成\<client>()类构造器，用于初始化接口中所定义的成员变量（接口只能有静态的）。
>
> ​	接口与类在主动引用场景中的第三种是有区别的，当接口初始化时，并不要求其父接口全部都要完成初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。



[^注2.1]:强调开始是因为这些阶段通常都是互相交叉地混合进行的。即这些阶段的开始时间是顺序的，但完成时间则不一定，因为一个阶段在执行的过程中会调用、激活另一个阶段

# 类加载过程

​	详细讲解加载、验证、准备、解析、初始化五个阶段所执行的具体动作。

## 加载

**加载**是 类加载 的一个阶段，注意不要混淆。

加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的二进制字节流。
- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

> **Tip**：
>
> ​	二进制字节流是类在传输中的表达，因为《Java虚拟机规范》并未对二进制字节流获取方式做限制，所以类并不只是可以从class文件中获取。

其中**二进制字节流**可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础；
- 从网络中获取，最典型的应用是 Applet；
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流；
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类；
- 从数据库中获取，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发；
- 从加密文件中获取，这是典型的防class文件被反编译的保护措施，通过加载时解码class文件来保障程序运行逻辑不被窥探；
- 等等...



​	相对于类加载的其他阶段，非数组类型的加载阶段（准确的说是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的阶段。加载阶段既可以使用 Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的**findClass()方法或loadClass()方法**），实现根据自己的想法来赋予应用程序获取运行代码的动态性。

## 验证



## 准备



## 解析



## 初始化



# 参考资料

《深入理解Java虚拟机：Java高级特性与最佳实践》第三版（该书的第7章）——周志明著