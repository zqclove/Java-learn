# 概述

​	java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。这种动态组装应用的方式目前已广泛应用于Java程序之中，从最基础的Applet、JSP到相对复杂的OSGi技术，都依赖着Java语言运行期类加载才
得以诞生。

​	为了避免语言表达中可能产生的偏差，在正式开始本章以前，笔者先设立两个语言上的约定：

​	第一，在实际情况中，每个Class文件都有代表着Java语言中的一个类或接口的可能，后文中直接对“类型”的描 述都同时蕴含着类和接口的可能性，而需要对类和接口分开描述的场景，笔者会特别指明；

​	第二，与前面介绍Class文件格式时的约定一致，本章所提到的“Class文件”也并非特指某个存在于具体磁盘中的文件，而应当是一串二进制字节流，无论其以何种形式存在，包括但不限于磁盘文件、网络、数据库、内存或者动态产生等。

# 类加载的时机

​	一个类型从被加载到虚拟机内存中开始到卸载为止，它的整个生命周期会经历**加载（loading）**、**验证（verification）**、**准备（preparation）**、**解析（resolution）**、**初始化（initialization）**、**使用（using）**和**卸载（unloading）**七个阶段。其中，验证、准备和解析三个部分统称为**连接（linking）**。

![类的生命周期](C:\Users\Administrator\Desktop\学习\java\Java-learn\img\类的生命周期.png)

​	如上图所示，**加载、验证、准备、初始化和卸载**这五个阶段的**顺序是确定的**，类型的加载过程必须按照这种顺序**开始**[^注2.1]，而**解析阶段不一样：它在某些情况下可以在初始化之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）**。

## 初始化时机

​	虚拟机规范中并**没有强制约束何时进行加载**，但是规范严格规定了**有且只有**下列六种情况**必须对类进行初始化**（加载、验证、准备都会随之发生）：

### 主动引用

- 遇到 `new`、`getstatic`、`putstatic`、`invokestatic`  这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 `new`  关键字实例化对象的时候；读取或设置一个类的静态字段（**被 final  修饰、已在编译期把结果放入常量池的静态字段除外**）的时候；以及调用一个类的静态方法的时候。
- 使用 **java.lang.reflect** 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
- 当使用 JDK 1.7 的动态语言支持时，如果一个 **java.lang.invoke.MethodHandle** 实例最后的解析结果为  **REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial** 四种类型的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；
- 当一个接口中定义了JDK 8新加入的默认方法（被`default`关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前初始化，

以上六种情形的行为被称为对一个类型的**主动引用**。

​	简而言之：在`new`、读取或设置静态字段（常量除外）、调用类的静态方法、反射调用、初始化类（先触发父类的初始化）、初始化主类（包含main（）方法）、有默认方法的接口的实现类初始化时，如果发现类（或接口）没有初始化，则需要先初始化类。



```java
public class InitializationTest {

    static {
        System.out.println("static");
    }

    public static void main(String[] args) {
        System.out.println("main");
    }
}
//主类在虚拟机启动时初始化。
```

### 被动引用

除主动引用外，所有引用类的方式都不会触发初始化，称为**被动引用**。被动引用的常见例子包括：

- **通过子类引用父类的静态字段**，不会导致**子类**初始化。

```java
System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
```

- **通过数组定义来引用类**，不会触发此类的初始化。**该过程会对数组类进行初始化**，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法（被public修饰的length属性和clone方法）。

```java
SuperClass[] sca = new SuperClass[10];
```

- **常量在编译阶段会存入调用类的常量池中**，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。（对于调用其它类的常量的类，都会转化为对自身常量池的引用，因此，这种调用产生的引用关系是不存在的。）

```java
System.out.println(ConstClass.HELLOWORLD);
```

> **Tip**：
>
> ​	接口的加载过程和类的加载过程有些不同。接口与类一样也有初始化过程，但类可以使用静态语句块，而接口不能使用静态语句块，但编译器仍然会为接口生成\<client>()类构造器，用于初始化接口中所定义的成员变量（接口只能有静态的）。
>
> ​	接口与类在主动引用场景中的第三种是有区别的，当接口初始化时，并不要求其父接口全部都要完成初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。



[^注2.1]:强调开始是因为这些阶段通常都是互相交叉地混合进行的。即这些阶段的开始时间是顺序的，但完成时间则不一定，因为一个阶段在执行的过程中会调用、激活另一个阶段

# 类加载过程

​	详细讲解加载、验证、准备、解析、初始化五个阶段所执行的具体动作。

## 加载

**加载**是 类加载 的一个阶段，注意不要混淆。

加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的二进制字节流。
- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

> **Tip**：
>
> ​	二进制字节流是类在传输中的表达，因为《Java虚拟机规范》并未对二进制字节流获取方式做限制，所以类并不只是可以从class文件中获取。

其中**二进制字节流**可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础；
- 从网络中获取，最典型的应用是 Applet；
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流；
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类；
- 从数据库中获取，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发；
- 从加密文件中获取，这是典型的防class文件被反编译的保护措施，通过加载时解码class文件来保障程序运行逻辑不被窥探；
- 等等...



​	相对于类加载的其他阶段，**非数组类型的加载阶段**（准确的说是加载阶段中获取类的二进制字节流的动作）是开发人员**可控性最强的阶段**。加载阶段既可以使用 Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的**findClass()方法或loadClass()方法**），实现根据自己的想法来赋予应用程序获取运行代码的动态性。



> ​	对于数组类来说，加载方式会有不同。因为数组类本身不通过类加载器创建，它是由 Java虚拟机直接在内存中动态构造出来的。但数组的元素类型最终还是由类加载器来完成加载。这里暂不展开，待日后研究再写。



​	加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是**交叉进行**的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这**两个阶段的开始时间仍然保持着固定的先后顺序**。

## 验证

​	验证是连接阶段的第一步，这个阶段的**目的是确保 Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身安全**。

​	验证阶段对虚拟机来说是非常必要的。在加载阶段，表示类的二进制字节流的获取方式是有很多种的。如果只在编译阶段保证代码安全，那么一些使用二进制编辑器（只有0和1，无需通过编译）编写的类就可直接进入虚拟机，而这些二进制字节流就可能会危害虚拟机的安全。为此，在二进制字节流进入虚拟机前需要进行验证，是虚拟机保护自身的一种措施。

由此可见，验证阶段可是重中之重[^注3.2.1]。而且从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程占了相当大的比重。从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：**文件格式验证**、**元数据验证**、**字节码验证**和**符号引用验证**：

- **文件格式验证**：

    ​	第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：

    - 是否以魔数0xCAFEBABE开头；
    - 主、次版本号是否在当前Java虚拟机接受范围之内；
    - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）；
    - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；
    - CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据；
    - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息；
    - ……（还有很多）

    ​	**该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内**，格式上符合描述一个Java类型信息的要求。这阶段的验证是**基于二进制字节流**进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以**后面的三个验证阶段全部是基于方法区的存储结构**上进行的，不会再直接读取、操作字节流了。

- **元数据验证**：

    ​		第二阶段是对字节码描述的信息进行**语义分析**，以保证其描述的信息符合《Java语言规范》的要求，这个阶段可能包括的验证点如下：

    - 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）；
    - 这个类的父类是否继承了不允许被继承的类（被final修饰的类）；
    - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；
    - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）；
    - ......

    ​	第二阶段的主要目的是**对类的元数据信息进行语义校验**，保证不存在与《Java语言规范》定义相
    悖的元数据信息。

- **字节码验证**：

    ​		第三阶段是整个验证过程中最复杂的一个阶段，主要目的是**通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的**。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：

    - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况；
    - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上；
    - 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。

    ​	如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。这里设计到离散数学的“停机问题”，不作深入。

    > **Tip**：
    >
    > ​	由于数据流分析和控制流分析的高度复杂性，Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行。
    >
    > ​	具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性，这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。这样就将字节码验证的类型推导转变为类型检查，从而节省了大量校验时间。
    >
    > ​	理论上StackMapTable属性也存在错误或被篡改的可能，所以是否有可能在恶意篡改了Code属性的同时，也生成相应的StackMapTable属性来骗过虚拟机的类型校验，则是虚拟机设计者们需要仔细思考的问题

- **符号引用验证**：

    ​		最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是**对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验**，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要校验下列内容：

    - 符号引用中通过字符串描述的全限定名是否能找到对应的类；
    - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段；
    - 符号引用中的类、字段、方法的可访问性（private、protected、public、\<package>）是否可被当前类访问；
    - ……

    ​	符号引用验证的主要目的是**确保解析行为能正常执行**，如果无法通过符号引用验证，Java虚拟机
    将会抛出一个`java.lang.IncompatibleClassChangeError`的子类异常，典型的如：
    `java.lang.IllegalAccessError`、`java.lang.NoSuchFieldError`、`java.lang.NoSuchMethodError`等。

> **Tip**：
>
> ​	类加载过程是很大可能会反复进行的，而反复验证一些类可能没有很大的意义，因此在生产环境的实施阶段可以考虑使用`-Xverify:none`参数来关闭大部分的类验证措施，以缩短类加载的时间。

[^注3.2.1]:验证过程在《Java虚拟机规范》中有大量的描述，制定了许多约束和验证规则。在这只做简便阐述，日后深入研究。

## 准备

​	准备阶段是**为类中定义的静态变量（类变量）分配内存并设置类变量初始值的阶段**。在JDK 7及之前，类变量所使用的内存都是在方法区中分配的；在JDK 8及之后，类变量随着**Class对象**一起存放在 Java堆中。

​	准备阶段进行内存分配的仅仅是类变量，不包括实例变量，实例变量会随着对象实例化时随着对象一起在 Java堆中分配。并且该阶段的初始值在一般情况下是数据类型的**零值**，例如一个类变量的定义为：

```java
public static int value = 123;
```

​	那变量 value 在准备阶段过后的初始值为 0 而不是 123。因为这时并没有开始执行任何 Java方法，而把变量 value 赋值为 123 的 `putstatic` 指令是程序被编译后，存放于类构造器\<client>() 方法之中，所以把变量 value 赋值为 123 的动作要到类的初始化阶段才会被执行。

​	该阶段也存在一种特殊情况：如果类变量是常量（类字段的字段属性表中的**ConstantValue属性**，即`final`修饰的字段），那么上面的类变量 value 会在准备阶段赋值为 123。

## 解析

​	解析阶段是 Java虚拟机将常量池中的**符号引用替换为直接引用的过程**。该阶段的两个主要角色，符号引用和直接引用的定义如下：

- **符号引用**：符号引用**以一组符号来描述所引用的目标**，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用的目标并不一定是已加载到虚拟机内存中的内容，因此符号引用是**与虚拟机实现的内存布局无关**的引用，它们的字面量形式定义在《Java虚拟机规范》的 Class文件格式章节中。
- **直接引用**：直接引用是**可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄**。直接引用是**与虚拟机实现的内存布局有关**的。同一个符号引用经过解析阶段，在不同虚拟机上得到的直接引用一般不会相同。而且直接引用的目标必定已经在虚拟机的内存中存在。



​	关于解析阶段发生的时机，《Java虚拟机规范》只要求在17个[^注3.4.1]用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。因此虚拟机实现可以根据需要自行判断，是在类被加载器加载时就对常量池中的符号引用进行解析，还是符号引用将被使用时才进行解析。

​	对于同一个符号引用进行多次解析请求是常见的情况。为此，虚拟机实现可以对第一次解析的结果进行缓存，例如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。解析阶段是具有“一致性”的，在同一个实体中，一个符号引用的解析只有一直成功和一直失败，即第一次的解析结果就决定了该符号引用往后的解析结果。不过对于 `invokedynamic` 指令，上面的规则就不成立了。因为该指令的目的本来就是用于动态语言支持的。

​	解析阶段会因符号引用类型的不同而产生不同的解析动作，在这先不作深入，日后研究。

### mark

[^注3.4.1]:anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic

## 初始化

​	**该阶段是对类变量的初始化。**

​	初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机**执行**类构造器 **\<clinit>() 方法**的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

​	**\<clinit>()  是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的**，编译器**收集的顺序由语句在源文件中出现的顺序决定**。特别注意的是，**静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。**例如以下代码：

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

关于 **\<clinit>()方法**：

- \<clinit>()方法与类构造器（即在虚拟机视角中的实例构造器**\<init>()方法**）不同，它不需要显式地调用父类构造器，Java虚拟机会**保证在子类的 \<clinit>()方法执行之前，父类的 \<clinit>()方法已经执行完毕**。这也就意味着父类的静态语句块优先于子类的变量赋值操作。
- \<clinit>()方法对于类或接口来说并**不是必须的**，如果类中**没有静态语句块**，也**没有对变量的赋值操作**，那么编译器可**以不为这个类生成 \<clinit>()方法**[^注3.5.1]。
- 接口虽然不能使用静态语句块，但仍然有变量初始化的赋值操作，因此也会生成\<clinit>()方法。但执行接口\<clinit>()方法时，**不需要先执行父接口的\<clinit>()方法**，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，实现类在初始化时也不会执行其接口的\<clinit>()方法。（但在JDK 8之后，定义了默认方法的接口会在其实现类初始化时，接口也会初始化，即执行\<clinit>()方法）
- Java虚拟机必须保证一个类的\<clinit>()方法在多线程环境下只有一个线程执行，其他线程都需要阻塞等待，直到初始化线程完成初始化。其他线程在完成初始化后不会再次进入\<clinit>()方法，因此一个类型只会初始化一次。

**个人总结**：**\<clinit>()方法**可以认为是类的初始化器，是类对象（Class类的对象）的构造器，用于给类变量赋值的构造器。

[^注3.5.1]:即使有使用static修饰的静态方法也可以不生成\<clinit>()方法

# 类加载器

​	Java语言设计**类加载器的目的就是为了让应用程序（开发者）自己决定如何去获取所需的类**，是开发者参与整个类加载过程的一种方式。

## 类与类加载器

​	类加载器不仅**用于实现类的加载动作**，而且还能**与类本身共同确定**该类在 Java虚拟机中的**唯一性**。每个类加载器都有独立的类名称空间。意味着比较两个类是否相同，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使两个类来源于同一个class文件，被同一个 Java虚拟机加载，只要加载它们的类加载器不同，那这两个类必然不相等。（对应于《Java虚拟机规范》中的加载约束）

​	这里所指的“相等”，包括代表类的**Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果**，也包括了**使用 `instanceof` 关键字做对象所属关系判定等各种情况**。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。

​	**个人总结**：由上述得知，类与类加载器的关系不仅是加载与被加载的关系，还有共同确定虚拟机内存中类的唯一性的合作关系。

## 双亲委派模型

​	从 Java虚拟机角度上看，类加载器只有**启动类加载器（Bootstrap ClassLoader，C++语言实现）**和**其他类加载器（Java语言实现）**。启动类加载器属于虚拟机的一部分；其他类加载器独立于虚拟机，全部继承自抽象类 **java.lang.ClassLoader**。

​	从 Java开发人员角度上看，类加载器可以分为三层类加载器、双亲委派的类加载结构（自JDK1.2之后）。这种类加载架构作为 Java类加载的主体结构，虽然这种架构在**Java模块化系统**出现后有一些调整变动，但主体结构未变。

​	*本节内容是针对 JDK 8及之前的版本*

​	三层类加载器包括**启动类加载器**、**扩展类加载器**、**应用程序类加载器**：

- **启动类加载器（Bootstrap ClassLoader）**：

    ​	此类加载器负责将存放在 **<JRE_HOME>\lib** 目录中的，或者被 `-Xbootclasspath`  参数所指定的路径中的，并且是虚拟机识别的（**仅按照文件名识别**，如 rt.jar，名字不符合的类库即使放在 lib  目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java  程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可（java.lang.ClassLoader.getClassLoader()方法返回null）。

- **扩展类加载器（Extension ClassLoader）**：

    ​	这个类加载器是由 **ExtClassLoader（sun.misc.Launcher$ExtClassLoader）以 Java代码形式实现**的。它负责将**<JAVA_HOME>/lib/ext** 或者被 `java.ext.dirs`  系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器来加载Class文件。

- **应用程序类加载器（Application ClassLoader）**：

    ​	这个类加载器是由 **AppClassLoader（sun.misc.Launcher$AppClassLoader）以 Java代码形式实现**的。由于这个类加载器是  ClassLoader 中的 **getSystemClassLoader()  方法的返回值**，因此一般称为**系统类加载器**。它**负责加载用户类路径（ClassPath）上所指定的类库**，这些类可以在使用 `-cp` 或 `-classpath` 命令行选项调用程序时设置。开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。



​	JDK 9之前，Java应用程序都是由上述的三种类加载器相互配合来完成加载的，用户也可以自定义类加载器进行扩展。下图展示了类加载器之间的协作关系，称**为双亲委派模型**，是最常用类加载器协作关系模型。



<img src="C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\img\双亲委派模型.png" alt="双亲委派模型" style="zoom: 80%;" />

​	双亲委派模型要求除了启动类加载器外，其余的类加载器都应有自己的父类加载器。不过该模型下类加载器之间的父子关系**一般不是以继承的方式实现**的，而是**以组合的方式实现**的。

​	双亲委派模型的**工作过程**：

1. 类加载器收到一个类的加载请求（该类没有被加载过）；
2. 类加载器委托其父类加载器去完成加载，重复该步骤直到将请求传送至“祖先”类加载器；
3. 如果当前父类加载器无法完成这个加载请求（它的搜索范围内没有找到这个类），那么将加载请求回送给其子类加载器去完成加载，重复该步骤直到能够加载完成；

​	这个过程就像是回旋镖，分为两个方向，丢出（找爸爸）和回旋（无法加载）。丢出的方向不会停止，只有到尽头（没有父类加载器）就会开始回旋；回旋的方向遇到障碍（当前类加载器能够完成加载）就会停止。

​	采用双亲委派模型组织类加载器之间的关系有如下**好处**：

- 类随着加载它的类加载器一起具备了带有优先级的层次关系，例如父类加载器和子类加载器的搜索范围都有该类的class文件（二进制字节流），那么父类加载器会先完成加载，而子类就不需要加载该类；
- 可以避免同一个类被不同类加载器多次加载（造成混乱），保证了类在程序的各种类加载器环境中都是同一个类（即类的唯一性得到保证，一致性问题）；



​	双亲委派模型的**实现**代码如下：

```java
public class MyClassLoader extends ClassLoader {

    private ClassLoader parent;

    public MyClassLoader() {
    }

    public MyClassLoader(ClassLoader parent) {
        this.parent = parent;
    }

    @Override
    public synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        Class c = findLoadedClass(name);
        if (c == null) {
            try {
                if (parent != null) {
                    c = parent.loadClass(name);
                } else {
                   	// 找启动类加载器
                }
            } catch (ClassNotFoundException e) {
              	// 父类加载器抛出该异常，表明父类无法加载
            }
            if (c == null) {
                c = findClass(name);
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] b = getClassFile();
        if (b == null) {
            throw new ClassNotFoundException();
        }
        return super.defineClass(name, b, 0, b.length); // 也可重写defineClass
    }
    
    private byte[] getClassFile() {
        byte[] b = new byte[4096];
        // 从某个地方获取class文件（二进制字节流）
        return b;
    }
}

```

​	主要是 **loadClass()**方法，在该方法中判断父类加载器是否存在，如果有就交给父类加载器去加载。代码中使用了组合的方式实现父子关系。对于 **findClass()**方法和 **defineClass()**方法，可以根据具体需求重写。用户在自定义类加载器时，可以不重写 **loadClass()**方法，因为 **java.lang.ClassLoader.loadClass()**方法已经实现了双亲委派模型的逻辑，用户自定义类加载器时，只需重写 **findClass()**方法即可。



​	**个人总结**：双亲委派模型像是设计模式，是开发人员在编写代码时的规范或建议，并不意味着必须这么做。即开发人员在编写自定义类加载器时，可以不委派父类加载器，甚至可以不实现类加载器之间父子关系。

## 破坏双亲委派模型

​	双亲委派模型主要出现过3次较大规模“被破坏” 的情况。第一次是发生在双亲委派模型出现之前；第二次是发生在基础类型（越上层的类加载器加载的类型越基础）需要调用用户代码的情况，例如 JNDI服务；第三次是用户对程序动态性的追求所导致的，这里的动态性是指**代码热替换**、**模块热部署**等，即后面说的 Java模块化系统。

​	这里不详细介绍这三种情况的细节，只是为了 Java模块化系统做铺垫。这里提一下第二次“被破坏”时的解决方案，引入了不优雅的**线程上下文加载器**，和之后的 **ServiceLoader**类。

### OSGi

​	OSGi（开放服务网关协议，Open Service Gateway Initiative）技术是 Java动态化模块化系统的一系列**规范**。OSGi实现模块化热部署的关键是**它自定义的类加载器的实现，每个程序模块（Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换**。由此看出OSGi环境下的类加载器不再是双亲委派模型的结构，而是一种更加复杂的网状结构。

​	当OSGi 收到类加载请求时，会按一下顺序进行类搜索：

1. 将以 `java.*` 开头的类，委派给父类加载器加载；
2. 否则，将委派列表名单内的类，委派给父类加载器加载；
3. 否则，将 Import列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载；
4. 否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载；
5. 否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载；
6. 否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载；
7. 否则，类查找失败。

​	上面的查找顺序只有开头两点符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的。



​	**个人总结**：OSGi 就是不同于双亲委派模型的另一种类加载器架构，目的是为了实现“热插拔”效果。

​	OSGi —— 日后研究！

# Java模块化系统

​	实现模块化的关键目标是**可配置的封装隔离机制**。JDK 9的模块不仅仅像之前的 Jar 包那样只是简单地充当代码的容器，除了代码之外，Java的模块还包含了以下内容：

- 依赖其他模块的列表；（我想要的模块）
- 导出的**包列表**，即其他模块可以使用的列表；（我给你用）
- 开放的**包列表**，即其他模块可反射访问模块的列表；（我给你用升级版）
- 使用的**服务列表**；（我想要的服务，具体想要的）
- 提供服务的**实现列表**；（我给你用的服务，外部具体需要的）



​	可配置的封装隔离机制



# 参考资料

《深入理解Java虚拟机：Java高级特性与最佳实践》第三版（该书的第7章）——周志明著