# 垃圾收集器与内存分配策略

# 概述

​	垃圾收集技术源自在1960年诞生于麻省理工学院的Lisp，这是第一门开始使用内存动态分配和垃圾收集技术的语言。

​	当Lisp还在胚胎时期时，其作者John McCarthy就思考过垃圾收集需要完成的三件事情：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？



​	在虚拟机的运行时数据区域中，虚拟机栈、虚拟机栈、本地方法栈这三个区域随线程而生，随线程而亡。虚拟机栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。

​	而 Java堆和方法区这两个区域则有着明显的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。

# 回收对象判断

​	垃圾收集器在对堆中对象进行回收前，第一件事情就是要确定哪些对象还“存活”着，哪些已经“死亡”（即不可能再被任何途径使用的对象）。 

## 引用计数算法

​	引用计数算法（Reference Counting）在对象中添加一个引用计数器，每当该对象被引用时，计数器值就加一；当引用失效时，计算器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

​	引用计数算法虽然占用一些额外的内存空间来进行计算，但原理简单，判定效率高，大多数情况下是不错的算法。但是在 Java领域，至少主流的 Java虚拟机都没有选用该算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况需要判断，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数器算法就很难解决对象之间的相互循环引用的问题。

​	如下对象相互循环引用的例子：

```java
public class ReferenceCountingGC {
    
	public Object instance = null;
    
	private static final int _1MB = 1024 * 1024;
    
	/**
	* 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
	*/
	private byte[] bigSize = new byte[2 * _1MB];
	public static void testGC() {
		ReferenceCountingGC objA = new ReferenceCountingGC();
		ReferenceCountingGC objB = new ReferenceCountingGC();
		objA.instance = objB;
		objB.instance = objA;
		objA = null;
		objB = null;
		// 假设在这行发生GC，objA和objB是否能被回收？
		System.gc();
	}
}
```

## 可达性分析算法

​	可达性分析算法涉及两个概念：GC Root 和 引用链。

​	GC Root同数据结构中的根节点概念相同，是其他对象的根对象（其他对象不是所有对象，是该跟对象引用链下的对象）。在 JVM中，GC Root不只有一个，有一系列根对象组成的起始节点集，被称为GC Roots（复数）。

​	引用链则类似树中子节点到根节点的路径，是对象间引用关系的结构表示，通过类似树路径的方式表达对象与根节点的引用关系。

​	可达性分析算法通过GC Roots作为起始点，根据引用链向下搜索，如果某个对象到GC Roots间没有任何引用链相连，或者说从GC Roots到该对象不可达时，则证明此对象是不可能再被使用的。

在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

​	除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。例如只针对区域A进行GC，发现对象A在区域A中不可达，但是在区域B存在对象A的引用，此时需要将区域B临时性地加入到集合中。这种情况多发生在分代收集和局部回收。（典型例子就是对新生代的局部回收，而新生代对象可能被老年代的对象引用）

## 引用类型

​	Java对于引用的传统定义是：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就成该reference数据是代表某块内存、某个对象的引用。在这种定义下，一个对象只有“被引用”和“未被引用”两种状态，对于一些可抛弃的对象则没有很好的定义。可抛弃对象指内存空间足够时，对象能保留在内存中，当内存紧张时，则抛弃这些对象。

​	在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。

### 强引用

​	强引用就是传统定义下的对象，是指在程序代码中普遍存在的引用赋值，即类似“ Object obj = new Object() ”这中引用关系。对象是强引用的情况下，只要存在引用链当中，垃圾收集器就永远不会回收该对象。

### 软引用

​	软引用是指一些有用但并非必须的对象。被软引用关联的对象只有在内存不够的情况下才会被进行第二次回收，如果这次回收还是没有足够内存，才会抛出内存溢出异常。即软引用能存活到内存不足前的时期。

​	使用SoftReference类实现软引用：

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

### 弱引用

​	弱引用是指非必须对象，但是它的强度比软引用要弱一些，只能存活到下一次GC发生为止，即当GC发生后，无论内存是否足够，都会回收掉被弱引用关联的对象。

​	使用WeekReference类实现弱引用：

```java
Object obj = new Object();
WeekReference<Object> wf = new WeekReference<Object>(obj);
obj = null;
```

### 虚引用

​	虚引用又称为“幽灵引用”或“幻影引用”，是最弱的一种引用。一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

​	使用 PhantomReference 来创建虚引用：

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

## finalize

​	被可达性分析算法判断为不可达的对象，并不是一定就会进行回收，只有**至少经过两次标记过程**才能真正宣告一个对象死亡：如果对象在进行可达性分析后发现不可达，该对象就会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。如果对象没有重写finalize（）方法，或者方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。

​	不可达对象被判定为有必要执行finalize（）方法，那么该对象会被放置在一个名为**F-Queue**的队列之中，并在稍后由一条虚拟机**自动建立的、低调度优先级的Finalizer线程**去执行它们的finalize（）方法。

​	在执行finalize（）方法时会存在很多问题，例如方法未运行结束就被虚拟机强行结束（因为虚拟机不承诺一定会等待它运行结束）。虚拟机不承诺的原因是，finalize（）方法可能执行缓慢，或者发生死循环等极端的情况，这很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。

​	**finalize方法是对象逃脱死亡的最后一次自救机会，并且机会只有一次。**收集器会对F-Queue中的对象进行第二次小规模的标记，如果对象成功自救，只要重新与引用链的任何一个对象关联集合，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那么第二次标记时它将被移出“即将回收”的集合；如果对象自救失败，那基本上就是真正的死亡了。

​	**PS：**finalize运行代价高，不确定性大，无法保证各个对象的调用顺序，该方法已被官方明确声明为不推荐使用的方法。



## 回收方法区

​	回收方法区中的类又称为**类的卸载**，是一个类的整个生命周期结束的时期。	

​	在《Java虚拟机规范》中并没有强制要求虚拟机在方法区中实现垃圾收集。方法区垃圾收集的性价比通常也是比较低的。对比于 Java堆的垃圾收集，方法区的垃圾收集条件苛刻，回收成果远低于 Java堆的。

​	**方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。**回收废弃常量与回收 Java堆对象非常类似，例如常量池中的字面量回收，当系统中没有任何一个引用该常量的字符串对象，且虚拟机也没有其他地方引用该字面量时，该字面量就是**废弃常量**（在 Java堆中类似不可达对象）。常量池中其他类（接口）、方法、字段的符号引用也与此类似。

​	判定一个类型是否属于“不再使用的类型”的条件比较苛刻，必须同时满足以下三个条件：

- 该类的所有实例已经被回收，Java堆中不再存在该类型及其任何派生子类的实例。
- 该类的类加载器已经被回收。该条件通常很难达到，除非是经过精心设计的可替换类加载的场景，如OSGi、JSP的重加载等。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。（我对于这句话的理解是：与该类——不再使用的类型相关的**类类型对象**没有被引用，即该类没有被反射访问）

​	当满足上述三个条件时，Java虚拟机被允许对该类进行回收。被允许是指需要通过参数进行控制，而不是像 Java堆中的对象一样没有了引用就会自然回收。关于是否要对类型进行回收，HotSpot虚拟机提供了**-Xnoclassgc**参数进行控制，还可以使用**-verbose：class**以及**-XX：+TraceClass-Loading**、**-XX：+TraceClassUnLoading**查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。

​	在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。



# 垃圾收集算法

​	从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。在这里以追踪式垃圾收集为主。

## 分代收集理论

​	分代收集名为理论，实则是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上： 

​	**1）弱分代假说：绝大多数对象都是朝生夕灭的。**

​	**2）强分代假说：经过越多次垃圾收集过程仍存在的对象，越是难以消亡的。**

​	根据这两个假说，衍生出了收集器应该将 Java堆划分出不同区域的设计原则。**大部分收集器将 Java堆分为两个主要区域：新生代和老年代**[^注3.1]。新生代存储弱分代假说中的对象，老年代存储强分代假说中的对象。通过分代的方式，垃圾收集器在回收时，主要针对新生代中的对象进行回收（因为它们容易“死”），如果新生代的对象经过特定次数（可以通过参数设置）的回收仍然存活，则会将其逐步晋升到老年代；对老年代则以低频率的方式回收这个区域。

​	垃圾收集器因为分代思想将 Java堆分成不同区域之后，就可以每次只回收一个或某些部分的区域——由此产生了“Minor GC”，“Major GC” 和 “Full GC” 这样回收类型的划分；也能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”，“标记-清除算法” 和 “标记-整理算法”等针对性的垃圾收集算法。

​	[可达性分析算法](#可达性分析算法)中也有提到关于分代收集带来的问题：新生代的对象可能会被老年代对象所引用。所以为了找出这些被引用的新生代对象，就需要额外遍历整个老年代中所有对象来确保可达性分析结果的正确性。但遍历整个老年代无疑会为内存回收带来很大的性能负担，为了解决整个问题，就需要对分代收集理论添加第三条经验法：

​	**3）跨代引用假说：跨代引用相对于同代引用来说仅占极少数。**

​	第三条假说也可以结合第一条假说和第二条假说结合推理得出：两个对象存在互相引用关系，是应该倾向于同时存活或者同时灭亡的。也就说老年代的对象引用新生代的对象，新生代的对象也就能够在多次垃圾收集中存活下来，从而晋升老年代，此时跨代引用也随机消除了。（但并不能说被老年代对象引用的新生代对象就一定能成为晋升为老年代对象，因为随着程序代码的执行，可能就不被引用了）

​	根据第三条假说，为了极少数的跨代引用而去扫描整个老年代显然是非常浪费时间的事情，也不必浪费空间为每一个对象记录是否存在及存在哪些跨代引用。只需要在新生代上建立一个全局的数据结构（称为**“记忆集”**，Remembered Set），这个数据结构将老年代划分出一小块，标识出老年代的哪一块内存会存在跨代引用。当垃圾收集器进行 Minor GC时，就将“记忆集”中的对象临时性的加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

------

> **Tips**：
>
> 在这里简单介绍上面提到的回收类型：
>
> - 部分回收（Partial GC）：指回收目标不是完整的整个 Java堆，而是其中的部分区域，分为如下几个：
>     - 新生代收集（Minor GC / Young GC）：目标只是新生代的垃圾收集。
>     - 老年代收集（Major GC / Old GC）：目标只是老年代的垃圾收集。针对老年代收集行为的垃圾收集器，目前只有CMS收集器会这样做。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，需按上下文区分到底是指老年代的收集还是整堆收集。
>     - 混合收集（Mixed GC）：目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器存在这种行为。
> - 整队收集（Full GC）：收集整个 Java堆和方法区的垃圾收集。



[^注3.1]: 区域的名称不一定是新生代和老年代，这只是业界主流的命名方式。在其他虚拟机，例如 IBM J9中对应称为“婴儿区（Nursery）” 和“长存区（Tenured）”，名字不同但含义一样。

