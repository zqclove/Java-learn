[TOC]

# 垃圾收集器与内存分配策略

# 概述

​	垃圾收集技术源自在1960年诞生于麻省理工学院的Lisp，这是第一门开始使用内存动态分配和垃圾收集技术的语言。

​	当Lisp还在胚胎时期时，其作者John McCarthy就思考过垃圾收集需要完成的三件事情：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？



​	在虚拟机的运行时数据区域中，虚拟机栈、虚拟机栈、本地方法栈这三个区域随线程而生，随线程而亡。虚拟机栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。

​	而 Java堆和方法区这两个区域则有着明显的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。

# 回收对象判定

​	垃圾收集器在对堆中对象进行回收前，第一件事情就是要确定哪些对象还“存活”着，哪些已经“死亡”（即不可能再被任何途径使用的对象）。 

## 引用计数算法

​	引用计数算法（Reference Counting）在对象中添加一个引用计数器，每当该对象被引用时，计数器值就加一；当引用失效时，计算器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

​	引用计数算法虽然占用一些额外的内存空间来进行计算，但原理简单，判定效率高，大多数情况下是不错的算法。但是在 Java领域，至少主流的 Java虚拟机都没有选用该算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况需要判断，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数器算法就很难解决对象之间的相互循环引用的问题。

​	如下对象相互循环引用的例子：

```java
public class ReferenceCountingGC {
    
	public Object instance = null;
    
	private static final int _1MB = 1024 * 1024;
    
	/**
	* 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
	*/
	private byte[] bigSize = new byte[2 * _1MB];
	public static void testGC() {
		ReferenceCountingGC objA = new ReferenceCountingGC();
		ReferenceCountingGC objB = new ReferenceCountingGC();
		objA.instance = objB;
		objB.instance = objA;
		objA = null;
		objB = null;
		// 假设在这行发生GC，objA和objB是否能被回收？
		System.gc();
	}
}
```

## 可达性分析算法

​	可达性分析算法涉及两个概念：**GC Root 和 引用链。**

​	GC Root同数据结构中的根节点概念相同，是其他对象的根对象（其他对象不是所有对象，是该跟对象引用链下的对象）。在 JVM中，GC Root不只有一个，有一系列根对象组成的起始节点集，被称为GC Roots（复数）。

​	引用链则类似树中子节点到根节点的路径，是对象间引用关系的结构表示，通过类似树路径的方式表达对象与根节点的引用关系。

​	可达性分析算法通过GC Roots作为起始点，根据引用链向下搜索，如果某个对象到GC Roots间没有任何引用链相连，或者说从GC Roots到该对象不可达时，则证明此对象是不可能再被使用的。

在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

​	除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。例如只针对区域A进行GC，发现对象A在区域A中不可达，但是在区域B存在对象A的引用，此时需要将区域B临时性地加入到集合中。这种情况多发生在分代收集和局部回收。（典型例子就是对新生代的局部回收，而新生代对象可能被老年代的对象引用）

## 引用类型

​	Java对于引用的传统定义是：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就成该reference数据是代表某块内存、某个对象的引用。在这种定义下，一个对象只有“被引用”和“未被引用”两种状态，对于一些可抛弃的对象则没有很好的定义。可抛弃对象指内存空间足够时，对象能保留在内存中，当内存紧张时，则抛弃这些对象。

​	在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。

### 强引用

​	强引用就是传统定义下的对象，是指在程序代码中普遍存在的引用赋值，即类似“ Object obj = new Object() ”这中引用关系。对象是强引用的情况下，只要存在引用链当中，垃圾收集器就永远不会回收该对象。

### 软引用

​	软引用是指一些有用但并非必须的对象。被软引用关联的对象只有在内存不够的情况下才会被进行第二次回收，如果这次回收还是没有足够内存，才会抛出内存溢出异常。即软引用能存活到内存不足前的时期。

​	使用SoftReference类实现软引用：

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

### 弱引用

​	弱引用是指非必须对象，但是它的强度比软引用要弱一些，只能存活到下一次GC发生为止，即当GC发生后，无论内存是否足够，都会回收掉被弱引用关联的对象。

​	使用WeekReference类实现弱引用：

```java
Object obj = new Object();
WeekReference<Object> wf = new WeekReference<Object>(obj);
obj = null;
```

### 虚引用

​	虚引用又称为“幽灵引用”或“幻影引用”，是最弱的一种引用。一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

​	使用 PhantomReference 来创建虚引用：

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

## finalize

​	被可达性分析算法判断为不可达的对象，并不是一定就会进行回收，只有**至少经过两次标记过程**才能真正宣告一个对象死亡：如果对象在进行可达性分析后发现不可达，该对象就会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。如果对象没有重写finalize（）方法，或者方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。

​	不可达对象被判定为有必要执行finalize（）方法，那么该对象会被放置在一个名为**F-Queue**的队列之中，并在稍后由一条虚拟机**自动建立的、低调度优先级的Finalizer线程**去执行它们的finalize（）方法。

​	在执行finalize（）方法时会存在很多问题，例如方法未运行结束就被虚拟机强行结束（因为虚拟机不承诺一定会等待它运行结束）。虚拟机不承诺的原因是，finalize（）方法可能执行缓慢，或者发生死循环等极端的情况，这很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。

​	**finalize方法是对象逃脱死亡的最后一次自救机会，并且机会只有一次。**收集器会对F-Queue中的对象进行第二次小规模的标记，如果对象成功自救，只要重新与引用链的任何一个对象关联集合，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那么第二次标记时它将被移出“即将回收”的集合；如果对象自救失败，那基本上就是真正的死亡了。

​	**PS：**finalize运行代价高，不确定性大，无法保证各个对象的调用顺序，该方法已被官方明确声明为不推荐使用的方法。



## 回收方法区

​	回收方法区中的类又称为**类的卸载**，是一个类的整个生命周期结束的时期。	

​	在《Java虚拟机规范》中并没有强制要求虚拟机在方法区中实现垃圾收集。方法区垃圾收集的性价比通常也是比较低的。对比于 Java堆的垃圾收集，方法区的垃圾收集条件苛刻，回收成果远低于 Java堆的。

​	**方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。**回收废弃常量与回收 Java堆对象非常类似，例如常量池中的字面量回收，当系统中没有任何一个引用该常量的字符串对象，且虚拟机也没有其他地方引用该字面量时，该字面量就是**废弃常量**（在 Java堆中类似不可达对象）。常量池中其他类（接口）、方法、字段的符号引用也与此类似。

​	判定一个类型是否属于“不再使用的类型”的条件比较苛刻，必须同时满足以下三个条件：

- 该类的所有实例已经被回收，Java堆中不再存在该类型及其任何派生子类的实例。
- 该类的类加载器已经被回收。该条件通常很难达到，除非是经过精心设计的可替换类加载的场景，如OSGi、JSP的重加载等。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。（我对于这句话的理解是：与该类——不再使用的类型相关的**类类型对象**没有被引用，即该类没有被反射访问）

​	当满足上述三个条件时，Java虚拟机被允许对该类进行回收。被允许是指需要通过参数进行控制，而不是像 Java堆中的对象一样没有了引用就会自然回收。关于是否要对类型进行回收，HotSpot虚拟机提供了**-Xnoclassgc**参数进行控制，还可以使用**-verbose：class**以及**-XX：+TraceClass-Loading**、**-XX：+TraceClassUnLoading**查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。

​	在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。



# 垃圾收集算法

​	从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。在这里以追踪式垃圾收集为主。

## 分代收集理论

​	分代收集名为理论，实则是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上： 

​	**1）弱分代假说：绝大多数对象都是朝生夕灭的。**

​	**2）强分代假说：经过越多次垃圾收集过程仍存在的对象，越是难以消亡的。**

​	根据这两个假说，衍生出了收集器应该将 Java堆划分出不同区域的设计原则。**大部分收集器将 Java堆分为两个主要区域：新生代和老年代**[^注3.1]。新生代存储弱分代假说中的对象，老年代存储强分代假说中的对象。通过分代的方式，垃圾收集器在回收时，主要针对新生代中的对象进行回收（因为它们容易“死”），如果新生代的对象经过特定次数（可以通过参数设置）的回收仍然存活，则会将其逐步晋升到老年代；对老年代则以低频率的方式回收这个区域。

​	垃圾收集器因为分代思想将 Java堆分成不同区域之后，就可以每次只回收一个或某些部分的区域——由此产生了“Minor GC”，“Major GC” 和 “Full GC” 这样回收类型的划分；也能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”，“标记-清除算法” 和 “标记-整理算法”等针对性的垃圾收集算法。

​	[可达性分析算法](#可达性分析算法)中也有提到关于分代收集带来的问题：新生代的对象可能会被老年代对象所引用。所以为了找出这些被引用的新生代对象，就需要额外遍历整个老年代中所有对象来确保可达性分析结果的正确性。但遍历整个老年代无疑会为内存回收带来很大的性能负担，为了解决整个问题，就需要对分代收集理论添加第三条经验法：

​	**3）跨代引用假说：跨代引用相对于同代引用来说仅占极少数。**

​	第三条假说也可以结合第一条假说和第二条假说结合推理得出：两个对象存在互相引用关系，是应该倾向于同时存活或者同时灭亡的。也就说老年代的对象引用新生代的对象，新生代的对象也就能够在多次垃圾收集中存活下来，从而晋升老年代，此时跨代引用也随机消除了。（但并不能说被老年代对象引用的新生代对象就一定能成为晋升为老年代对象，因为随着程序代码的执行，可能就不被引用了）

​	根据第三条假说，为了极少数的跨代引用而去扫描整个老年代显然是非常浪费时间的事情，也不必浪费空间为每一个对象记录是否存在及存在哪些跨代引用。只需要在新生代上建立一个全局的数据结构（称为**“记忆集”**，Remembered Set），这个数据结构将老年代划分出一小块，标识出老年代的哪一块内存会存在跨代引用。当垃圾收集器进行 Minor GC时，就将“记忆集”中的对象临时性的加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

------

> **Tips**：
>
> 在这里简单介绍上面提到的回收类型：
>
> - 部分回收（Partial GC）：指回收目标不是完整的整个 Java堆，而是其中的部分区域，分为如下几个：
>     - 新生代收集（Minor GC / Young GC）：目标只是新生代的垃圾收集。
>     - 老年代收集（Major GC / Old GC）：目标只是老年代的垃圾收集。针对老年代收集行为的垃圾收集器，目前只有CMS收集器会这样做。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，需按上下文区分到底是指老年代的收集还是整堆收集。
>     - 混合收集（Mixed GC）：目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器存在这种行为。
> - 整队收集（Full GC）：收集整个 Java堆和方法区的垃圾收集。



[^注3.1]: 区域的名称不一定是新生代和老年代，这只是业界主流的命名方式。在其他虚拟机，例如 IBM J9中对应称为“婴儿区（Nursery）” 和“长存区（Tenured）”，名字不同但含义一样。

## 标记-清除算法

​	**标记-清除算法**是最早出现，也是最基础的垃圾收集算法。就如其名字一般，该算法分成两个阶段："标记"和“清除”。**首先标记所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。**也可以标记存活对象，回收未被标记的对象。

​	标记-清除是最基础的垃圾收集算法，虽然逻辑简单，实现容易，但也存在许多问题：

1. 执行效率不稳定。如果 Java堆中包含大量对象，而且其中大部分对象是需要被回收的，这时必须进行大量的标记和清除动作，也就是说执行效率会随着对象增长而降低。
2. 内存空间碎片化问题。标记和清除动作之后，会在内存中产生大量不连续的内存碎片，当内存碎片过多时，可能会导致以后在程序运行中需要给大对象分配内存时无法找到足够的连续内存空间，就此不得不再一次触发垃圾收集。

## 标记-复制算法

​	**标记-复制算法**主要思想体现在复制，因此也被简称为复制算法。该算法主要为了解决标记-清除算法面对大量对象回收时执行效率低的问题。

​	标记-复制算法主要将可用内存分为两块，一块用作**存储区域**，一块用作**保留区域**。每一次垃圾收集，会将存储区域中存活的对象复制到保留区域，然后再清除存储区域的对象。

​	该算法不用考虑空间碎片的问题，只要移动堆顶指针，按序分配即可。算法实现简单，运行高效，但也同样有许多问题：

1. 内存间复制的开销。如果存储区域大部分对象为存活对象，那么在复制工作就会很大。
2. 两块区域占比分配。如果保留区域过大，就会对空间造成浪费；如果保留区域过小，就可能不足以存放存活对象。

​	对于问题1，我们可以根据弱分代假说，将复制算法应用于新生代，而非老年代，那么就可以避免出现问题1的情况（但是未从根本上解决，只是避免）。

​	对于问题2，1969年Fenichel提出了一种称为“半区复制（Semispace Copying）”的垃圾收集算法，将区域分为容量大小相同的两块。这也是标记-复制算法的最初模型。

​	在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，成为**“Appel式回收”**。**Appel式回收具体做法**是把新生代分为一块较大的**Eden空间**和两块较小的**Survivor空间**，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，就将Eden和Survior中仍存活的对象一次性复制到另一块Survivor空间上，然后直接清理Eden和已使用过的Survivor空间。（HotSpot虚拟机的Serial、ParNew等新生代收集器均采用这种策略来设计新生代的内存布局）

​	HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，即新生代中可用于分配对象的空间为整个新生代容量的90%，只有一个Survivor空间（剩下10%）是浪费的。

​	Appel式回收虽然减少了空间浪费的可能性，但也存在保留区域无法存放过多存活对象的可能。因此，Appel回收还有一个充当罕见情况的“逃生门”的安全设计，当剩余的Survivor空间不足以存放一次Minor GC之后的存活对象时，就需要依赖其他内存区域（大多数就是老年代）进行分配担保（Handle Promotion）。

​	分配担保详情参见[空间分配担保](#空间分配担保)

## 标记-整理算法



# HotSpot的算法实现细节

## 根节点枚举

​	回收对象判定使用的是可达性分析算法，该算法在耗时最长的查找引用链过程可以做到与用户线程并发执行（见[并发的可达性分析](#并发的可达性分析)），而可达性分析需要从根节点出发。因为根节点集合的对象引用关系会随着用户线程的执行而发生变化，所以为了保证一致性就需要暂停用户线程，否则分析结果的准确性无法保证。根节点枚举也是导致垃圾收集过程需要停顿的原因。

​	准确性得到保证，而检索根节点的问题还是存在。垃圾收集器需要知道哪些节点是根节点，才能通过可达性分析算法标记回收对象，而根节点枚举需要检查所有执行上下文和全局引用位置，工作量极大。为了减少根节点枚举的工作，现在主流Java虚拟机使用的都是**准确式垃圾收集（准确式内存管理）[^注3.1.1]**。

​	在HotSpot虚拟机中，其解决方案是使用一组成为`OopMap`的数据结构达到准确式内存管理。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在“特定的位置”记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。

​	根据准确式内存管理的思想，垃圾收集器在枚举根节点时，就可以避免对执行上下文和全局的引用位置进行扫描，从而减少停顿时间。

​	**自我理解**：虚拟机通过为指令生成`OopMap`记录引用位置，`OopMap`通过偏移量和大小标记对象的引用有效范围。

[^注3.1.1]:准确式内存管理是指虚拟机可以知道内存某个位置的数据具体是什么数据类型。即虚拟机有能力分别出一个数据是引用类型还是整数类型。

## 安全点

​	根节点枚举可以通过`OopMap`解决，但还存在着导致引用关系，或者说导致`OopMap`内容变化的指令非常多的问题，如果为每一条指令都生成对应的`OopMap`，那将会需要大量的额外空间，这种代价是难以容忍的。

​	为此，HotSpot只在“特定的位置”记录`OopMap`，这些位置被称为**安全点（safe point）**。用户程序的执行路径只有经过安全点时才能够暂停。因此安全点的选定既不能太少而让垃圾回收线程等待过久，也不能太过频繁以至于过分增大运行的内存负荷。**安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的**，因为每条指令执行时间很短，程序不太可能因为指令流长度太长而长时间执行，**“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用**，所以只有具有这些功能的指令才会产生安全点。（在内存分配的地方，同样可以设置`safe point`，例如`new`一个新对象的时候）

​	安全点上停止线程的方式有两种：**抢先式中断**和**主动式中断**。

- **抢断式中断**：不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现用户线程中断的地方不在安全点上，就恢复线程执行，直到跑到安全点上就中断；（很少虚拟机采用过这种方式）
- **主动式中断**：当垃圾收集需要中断线程的时候，不直接对线程操作，只是简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志位，一旦发现**中断标志为真时**就自己在最近的安全点上**主动中断挂起**。**轮询标志的地方和安全点是重合的**，另外还要加上所有创建对象和其他需要Java堆上分配内存的地方，这是为了检查是否即将发生垃圾收集，避免没有足够内存分配新对象；



​	因为轮询操作在程序执行时频繁出现，就需要轮询足够高效。HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程序。即虚拟机将某个**内存页设置为不可读**，线程执行到`test`指令（会访问那个不可读的内存页）时就会发生一个自陷异常信号，然后在预先注册的异常处理程序中挂起线程实现等待。这样仅通过一个汇编指令便完成安全点轮询和触发线程中断。

## 安全区域

​	使用安全点的设计似乎已经完美解决如何停顿用户线程，让虚拟机进入垃圾回收状态的问题了，但实际情况却并不一定。安全点机制保证了**程序执行时**，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，**程序“不执行”**的时候呢？

​	所谓的程序不执行就是没有分配处理器时间，典型的场景便是**用户线程处于Sleep状态或者Blocked状态**，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就必须引入**安全区域（Safe Region）**来解决。

​	**安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。**我们也可以把安全区域看作**被扩展拉伸了的安全点**。

​	当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。

​	**自我总结**：安全区域是不改变引用关系的代码段。那么当线程阻塞或睡眠时，也不会改变引用关系，即线程阻塞或睡眠时会将自己标识进入安全区域，待唤醒时自己去判断是否能够继续执行。

​	另外，当一个线程在执行native方法时，由于此时该线程在执行JVM管理之外的代码，不能对JVM的执行状态做任何修改，因而JVM要进入safepoint不需要关心它。所以也可以把正在执行native函数的线程看作“已经进入了safepoint”，或者把这种情况叫做“在safe-region里”。

## 记忆集与卡表

​	**记忆集是一种用于从非收集区域指向收集区域的指针集合的抽象数据结构**。这里说记忆集是抽象数据结构的意思是只定义了记忆集的行为意图，并没有定义其行为的具体实现。记忆集的具体实现很多种，可以是不考虑效率和成本的**含所有跨代引用的对象数组**来实现。但为了节约存储成本和维护成本，设计者提供了如下可供选择（当然也可以选择这个范围之外的）的记录精度：

- **字长精度**：每个记录精确到一个机器字长（就是处理器的寻址位数，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
- **对象精度**：每个记录精确到一个对象，该对象里有字段包含跨代指针。
- **卡精度**：每个记录精确到一块内存区域，该区域有对象含有跨代指针。

​	其中，第三种“卡精度”所指的是用一种称为“**卡表**”的方式去实现记忆集，卡表定义了记忆集的记录精度、与堆内存n的映射关系等。

​	卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的。以下这行代
码是HotSpot默认的卡表标记逻辑

```c++
CARD_TABLE [this address >> 9] = 0;
```

​	字节数组**CARD_TABLE**的**每一个元素都对应着其标识的内存区域中一块特定大小的内存块**，这个内存块被称作“**卡页**”（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数，通过上面代码可以看出HotSpot中使用的卡页是2的9次幂，即512字节（地址右移9位，相当于用地址除以512）。那如果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块。

​	一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）**对象的字段存在着跨代指针**，那就将**对应卡表的数组元素的值标识为 1**，称为这个元素**变脏（Dirty）**，没有则标识为 0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

## 写屏障



## 并发的可达性分析

​	目前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，**可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析**，这就意味着必须冻结全部用户线程的运行。

​	可达性算法不同于根节点枚举，GC Roots相比整个堆对象的数量要少很多，且在各种优化技巧（如`OopMap`）的

加持下，根节点枚举的停顿是非常短暂且相对固定的（不随着堆容量而增长）。

​	而可达性分析算法需要从GC Roots向下遍历对象，这一步骤所需的时间与 Java堆容量成正比关系：堆越大，存储的对象越多，对象图结构越复杂，需要标记的对象也越多，也就导致可达性分析算法的执行时间增加。

​	由上述可知，可达性分析算法的停顿会造成应用系统长时间的停摆，这对于时间敏感的应用是致命的。为此，可达性分析的步骤需要并发执行。

​	在并发的可达性分析算法中，虽然解决了停顿问题，但却无法保证一致性的问题。

## 参考资料

[深入探究 JVM | Safepoint 及 GC 的触发条件]: https://www.sczyh30.com/posts/Java/jvm-gc-safepoint-condition/



# 经典垃圾收集器

![收集器间的关系](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\img\收集器间的关系.png)

​	上图展示了七种作用于不同分代的收集器，两个收集器中存在连线表示可以搭配使用（红色连线表示在JDK1.9中已经完全取消了这些组合的支持）。

## Serial收集器

​	Serial收集器是最基础、历史最悠久的收集器。该收集器是一个单线程工作的收集器，但它的“单线程”的意义不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。"Stop the world"这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉，这对许多应用来说都是不能接受的（在后面收集器也只是缩短停顿时间，仍然没有办法彻底消除）。

![Serial收集器运行过程](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\img\Serial收集器运行过程.png)

​	上图为**Serial / Serial Old**收集器运行示意图。					

​	Serial收集器虽然是最基础的收集器，但它也有着优于其他收集器的地方。Serial收集器**简单而高效**（与其他收集器的单线程相比），**对于内存资源受限的环境**，它是所有收集器中**额外内存消耗最小**的；**对于单核处理器或处理器核心数较少的环境**来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得**最高的单线程收集效率**。

​	在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。

​	Serial收集器是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，该收集器对于运行在客户端模式下的虚拟机是一个很好的选择。

## ParNew收集器

​	ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时处理多条线程进行垃圾收回收之外，其余的行为包括Serial收集器可用的控制参数[^注5.2.1]、收集算法、STW、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上两种收集也是共用了相当多的代码。

![ParNew_SerialOld收集器运行过程](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\img\ParNew_SerialOld收集器运行过程.png)

​	ParNew收集器已经是被HotSpot虚拟机淘汰的虚拟机。在淘汰之前，它是除了Serial收集之外，唯一一个能与CMS收集器配合工作的收集器[^注5.2.2]（CMS后面介绍）。因为ParNew多线程并行的功能，它多用于服务端模式下的虚拟机。

> **并行与并发：**
>
> 这里的并行与并发是在讨论垃圾收集器中的**用户线程**的**GC线程**状态，有点不同于并发编程中的并行与并发，但大概意思是相近的。
>
> **并行：**描述的是**多条收集器线程之间的关系**，说明同一个时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。
>
> **并发：**描述的是**垃圾收集器线程与用户线程之间的关系**，说明同一时间垃圾收集器线程与用户线程都在运行中。此时程序仍然能够响应服务请求，但因为收集器线程占用部分系统资源，程序的处理的吞吐量会受到一定影响。

[^注5.2.1]:例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、-XX：HandlePromotionFailure等
[^注5.2.2]:在JDK1.9之后取消了对Serial与CMS的组合支持，而另一个新生代收集器Parallel Scavenge因为与CMS的目标不同，以及未使用分代框架的原因（G1收集器也未使用分代框架），因此无法与老年代收集CMS进行搭配。

## Parallel Scavenge收集器

​	Parallel Scavenge收集器（下称PS）从特性上看与ParNew收集器有着许多相似之处：都是新生代收集器、都是基于标记-复制算法实现的收集器、都是并行收集的多线程收集器。

​	PS收集器主要是关注点与其他收集器不同，其目标在于达到一个可控制的吞吐量，而其他收集器目标是尽可能缩短垃圾收集时用户线程的暂停时间。

​	**吞吐量是指处理器处于运行用户代码的时间与处理器总消耗时间的比值。**如下所示：
$$
吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)
$$
​	高吞吐量可以最高效率地利用处理器资源，能够尽快完成程序运算任务，主要适合在后台运算而不需要太多交互的分析任务。

​	

​	PS收集器提供了两个参数用于精确控制吞吐量，分别是**控制最大垃圾收集停顿时间**的`-XX：MaxGCPauseMillis`参数以及**直接设置吞吐量大小**的`-XX：GCTimeRatio`参数。

​	`-XX:MaxGCPauseMillis`参数允许的值是一个大于0的毫秒数，收集器将尽力保证垃圾收集时间不超过设定值。不过值得一提的是，该参数越小并不意味着垃圾收集速度越快，因为垃圾收集停顿时间缩短是以吞吐量和新生代空间为代价换取来的。新生代空间小又说明发生垃圾收集会更加频繁，使得垃圾收集时间占处理器总消耗时间的比值更大，吞吐量下降。

`	-XX:GCTimeRatio`参数的值是一个大于0且小于100的数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间，即`1/(1+x)`中的`x` 。

​	PS收集器与其他收集器关注点不同，主要关注吞吐量，也被称为“**吞吐量优先收集器**”，因此对于一些分代内存大小细节的参数，可以使用PS收集器中的参数`-XX:+UseAdaptiveSizePolicy`自动设定大小。激活该参数后，虚拟机会根据系统当前运行情况性能收集监控信息，动态调整新生代大小（`-Xmm`）、`Eden`与`Survivor`的比例（`-XX:SurvivorRatio`）、晋升老年代对象大小（`-XXPretenureSizeThreshold`）等细节参数，以及提供最合适的停顿时间或最大的吞吐量。这种调节策略成为**垃圾收集的自适应调节策略**。

​	如果觉得手工优化存在困难的话，使用PS收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成也许是一个很不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用`-XX：MaxGCPauseMillis`参数（更关注最大停顿时间）或`-XX：GCTimeRatio`（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是PS收集器区别于ParNew收集器的一个重要特性。

## Serial Old收集器

​	Serial Old收集器是Serial收集器的老年代版本，同样使用单线程模式执行垃圾收集，收集算法使用的是标记-整理算法。该收集器与Serial收集器相同，主要在客户端模式下的HotSpot虚拟机使用。

![ParNew_SerialOld收集器运行过程](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\img\Serial收集器运行过程.png)

​	*上图与Serial收集器运行过程的图是一样的。*

## Parallel Old收集器

​	Parallel Old收集器是PS收集器的老年代版本，同样是并行收集器，收集算法采用的是**标记-整理**算法实现。该收集器是在 JDK1.6时才开始提供的。直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑PS+Parallel Old收集器这个组合。

![Parallel Scavenge+Parallel Old收集器运行过程](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\img\Parallel Scavenge+Parallel Old收集器运行过程.png)

## CMS收集器

​	CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。适用于对响应速度有着较高要求的网站或B/S系统的服务端。

​	CMS收集器是基于标记-清除算法实现的，它的运行过程比较复杂，可以分为四个步骤：**初始标记、并发标记、重新标记、并发清除**。

​	初始标记和重新标记依然会暂停所有用户线程，但时间很短。并发标记和并发清除则是与用户线程并发执行，时间耗时较长。

​	**初始标记工作**：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；

​	并发标记工作：从初始标记中标记的对象（这里的对象是部分还是全部？）开始遍历整个对象图的过程，这个过程耗时较长但不需要暂停用户线程，垃圾收集线程与用户线程一起并发运行；

​	**重新标记工作**：因为并发标记是与用户线程并发执行的，在并发标记过程中，用户线程继续运行可能会导致标记产生变动（详见[并发的可达性分析](#并发的可达性分析)中的“增量更新”）。重新标记就是为了修正这些产生变动的标记记录，这个阶段的停顿时间通常会比初始标记稍长，远比并发阶段的时间短；	

​	**并发清除工作**：清除标记阶段所标记的“已死亡”对象，因为不用移动存活对象，所以可以与用户线程并发执行；

​	CMS收集器主要是将STW导致的停顿时间缩短，减少停顿时间的占比，从而实现伪并发（并未做到全程并发）的垃圾收集工作。下图为CMS收集器的运行过程：![CMS收集器运行过程](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\img\CMS收集器运行过程.png)

​	虽然CMS收集器因并发收集、低停顿的特性深受一些对响应速度严格要求的系统的喜爱，但它同样存在着一些问题。这些问题也是因为其并发的特性产生的。

​	问题一：**CMS收集器并发的特性会对处理器非常敏感**（并发的程序一般都对处理器比较敏感）。在收集器线程并发执行时，同样需要占用一部分处理器资源，这样就会导致应用程序变慢，降低吞吐量。**CMS默认启动的回收线程数是（处理器核心数量+3）/4**，随着处理器核心数量的增加，回收线程数的占比会下降。但是如果处理器核心数量较少，回收线程数就会占比较大，这时就不推荐使用CMS收集器。

​	问题二：**CMS处理器无法处理“浮动垃圾”**，有可能出现“Concurrent Mode Failure”并发失败进而导致另一次完全“STW”的Full GC的产生。“浮动垃圾”是指在并发阶段，用户线程继续执行的过程中会不断产生新的垃圾对象。这些“浮动垃圾”的处理也就不得不交给下一次垃圾收集处理。

​	问题三：**触发CMS收集的空间占比**。在垃圾收集的并发阶段，用户线程继续执行，需要产生新的对象时，需要请求新的可用空间。为了解决并发阶段的用户请求可用空间的问题，CMS收集器会在并发运行阶段预留空间给用户线程使用，即CMS收集会根据`-XX：CMSInitiatingOccupancyFraction`的值（老年代对象已使用多少百分的空间）触发垃圾收集的时机。ar如果该参数过低，垃圾收集的频率就会过高，导致性能变差；如果该参数过高，垃圾回收速度赶不上分配内存速度，就可能导致在CMS运行期间的预留空间无法满足用户线程需求空间，就会出现一次“并发失败”（Concurent Mode Failure），此时就会冻结用户线程，临时启用Serial Old收集器重新进老年代收集的后备方案，这样停顿时间就很长了。所以，上述参数需要在生产环境根据实际情况进行调整大小。

​	问题四：**标记-清除算法导致的空间碎片**。因为CMS是基于标记-清除算法实现的收集器，所以在收集结束时就会导致大量空间碎片产生。一旦空间碎片过多，导致无法给大对象分配空间时，就不得不提前触发一次Full GC。而Full GC是需要移动对象的，无法并发执行，就会使得停顿时间变长。CMS收集器提供了两个参数（但都在JDK1.9废除）：`-XX:+UseCMSCompactAtFullCollection`开关参数、`-XX:CMSFullGCsBeforeCompaction`。这两个参数可以控制关于Full GC的策略。

## Garbage First收集器

​	Garbage First（简称G1）收集器是一款面向局部收集设计思路和基于**Region**内存布局形式的收集器。

​	对于Region，G1收集器将连续的 Java堆分成**大小相等**的区域，这个区域即为**Region**。G1收集器内存布局还是基于分代收集理论设计的，但对于老年代和新生代的划分变得“灵活”许多，**不再是固定的**。“灵活”体现在每个Region都可以按照需求扮演Eden空间、Survivor空间或者老年代空间，意味着老年代和新生代是动态集合（Region不需要连续）。同样的，对于不同的角色，收集器也会采取不同的策略去处理。

​	Region中还有一类特殊的**Humongous区域**，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数`-XX：G1HeapRegionSize`设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些**超过了整个Region容量的超级大对象**，将**会被存放在N个连续的Humongous Region**之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。

​	G1收集器将Java对分成多个大小相等Region区域，并为每个Region区域评估“价值”，**价值即回收所获得的空间大小以及回收所需时间的经验值**，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用数`-XX：MaxGCPauseMillis`指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region。不再根据新生代和老年代进行回收，而是根据区域回收，这就是G1收集器的 Mixed GC模式。

​	**对于分代设计中跨代引用的问题**：G1收集器也是采用记忆集的方式避免“全堆扫描”，但G1收集器上的记忆集实现比较复杂，每个Region都维护自己的记忆集，这些记忆集会记录下别的Region指向自己的指针（引用），并标记这些指针分别在哪些卡页范围之中。**G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。**这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。

​	**对于并发标记阶段收集线程与用户线程的问题**：

- ​	对于并发标记时，**用户线程改变对象引用关系的问题**，G1收集采用**原始快照（SATB）**算法（详见[并发的可达性分析](#并发的可达性分析)中的“原始快照”）实现的。

- ​	**对于回收过程中新创建对象的内存分配问题**，G1为每一个Region设计了两个名为**TAMS**（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时**新分配的对象地址都必须要在这两个指针位置以上**。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。



​	如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器运作过程大致可划分为四个步骤：**初始标记**、**并发标记**、**最终标记**、**筛选回收**；

​	**初始标记**：只是标记一下GC Roots能直接关联到的对象，并修改TAMS指针的值。这个阶段需要暂停用户线程，但耗时短，而且是借用进行Minor GC的时候同步完成的。

​	**并发标记**：从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，标记出需要回收的对象。整个阶段耗时较长，但可与用户线程并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。

​	**最终标记**：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。

​	**筛选回收**：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

​	G1收集器运行过程示意图如下：

![G1收集器运行过程](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\img\G1收集器运行过程.png)

## 总结

​	对于不同收集器的实现，都会有不同的适用场景。对于收集器来说，主要关注点有两个：**吞吐量和停顿时间。**根据收集器的关注点的不同，也会有不同的收集策略。

​	我们并不用死记每个收集器的内容，而是根据关注点和分代理念去理解每个收集器，通过发散思维去记忆。

​	每个收集器也会有一些参数供用户自定义收集策略，比如停顿时间参数，运行垃圾收集时间占比参数等。设置这些参数时不应过高或过低，设置成对于应用来说合适的值即可。

# 低延迟垃圾收集器

待

# 选择合适的垃圾收集器

待

# 实战：内存分配与回收策略

​	对象的内存分配，从概念上讲应该在**堆上分配**，而实际上也可能经过**即时编译**被拆散为**标量类型**并间接地在**栈上分配**（**逃逸分析**）。在经典分代的设计下，新生对象通常会分配在新生代中，少数情况下（例如对象大小超过一定阈值）也可能会直接分配在老年代。对象分配的规则并不是固定的，《Java虚拟机规范》并未规定新对象的创建和存储细节，这取决于虚拟机当前使用的是哪一种垃圾收集器，以及虚拟机中与内存相关的参数的设定。

​	本节的代码如无特殊说明，均使用HotSpot虚拟机，以客户端模式运行。

## 对象优先在Eden分配

大多数情况下，对象在新生代**Eden**区中分配。当**Eden**区没有足够空间进行分配时，虚拟机将发起一次**Minor GC**

通过以下代码进行测试，根据垃圾收集日志查看内存各区域分配情况：

```java
/*
 * VM参数: 
 -verbose:gc 
 -Xms20M 
 -Xmx20M 
 -Xmn10M 
 -XX:+PrintGCDetails 
 -XX:SurvivorRatio=8 
 -client          
 -XX:+UseSerialGC 使用Serial收集器，使用其他收集器可能会有不一样的日志信息
 */
public class MinorGCTest {
    private static final int _1MB = 1024 * 1024;
    
    public static void testAllocation() {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB];
    }
    
    public static void main(String[] args) {
        testAllocation();
    }
}
```

​	上面代码我们将整个堆空间设置为20M，新生代和老年代空间各占10M，新生代中**Eden**与**Survivor**的比例为**8：1**。在 **testAllocation()** 中，分配三个2MB大小和一个4MB大小的对象。

​	由理论可知，三个2MB大小的对象会先在**Eden**进行分配，当要分配4MB大小的对象时，8MB的**Eden**区空间不足，因此会产生一次**Minor GC**，然后再在**Eden**区分配4MB大小的对象。

​	我们通过以上代码运行验证理论是否正确，垃圾收集日志信息如下：

![MinorGC日志](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\img\MinorGC日志.png)

​	查看日志信息：

**[GC (Allocation Failure) ....]** ：该信息表明发生了GC，其中**GC**（没有Full修饰）表明发生一次**Minor GC**，**Allocation Failure**表明本次GC的原因是在没有足够的空间能够存储新数据。

**[DefNew: 6964K->516K]**：该信息表明一次GC后新生代空间大小由6964K变成516K（516K会放到**Suvivor**区）。

**eden space** 的空间信息表明已使用4MB的大小，说明4MB大小的对象在一次GC后会在**Eden**区分配。

**tenured generation**的空间信息表明老年代会因为**分配担保机制**（**Suvivor**区空间不够分配）给三个2MB大小的对象分配空间。

​	通过垃圾收集日志我们可以判断理论正确，即**对象优先在Eden分配，当Eden区空间不足以分配时，就会发生一次Minor GC**。

------

​	**个人问题**：在验证理论过程中（jdk版本：openjdk version 1.8.0_265），如果不使用`-XX:+UseSerialGC`声明使用**Serial**收集器，会发现在分配4MB大小的对象时，本应发生一次**Minor GC**的情况并未发生，而是直接将4MB大小的对象分配到**老年代区域**。使用`Java -XX:+PrintCommandLineFlag -verison `查看该版本的默认收集器，发现有`-XX:+UseParalleGC`默认参数，表明该版本默认收集器是**Parallec**。并且实验表明该收集器会将大对象直接分配到老年代？

​	参考博客https://www.cnblogs.com/grey-wolf/p/9217497.html

## 大对象直接进入老年代

​	**大对象就是指需要大量连续内存空间的Java对象**，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组，本节例子中的**byte[]数组**就是典型的大对象。大对象对虚拟机的内存分配来说就是一个不折不扣的坏消息，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，我们写程序的时候应注意避免。

​	大对象在分配空间时，容易导致明明还有不少空间就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。

​	HotSpot虚拟机提供了`-XX：PretenureSizeThreshold`参数，**指定大于该设置值的对象直接在老年代分配**，这样做的目的就是避免在**Eden区**及两个**Survivor区**之间来回复制，产生大量的内存复制操作。

​	例子和代码还是和上节一样，只不过添加了VM参数：`-XX:PretenureSizeThreshold=3145728`（该参数不能与`-Xms`之类的参数一样直接写3MB）。按照理论，会在**Eden区**分配三个2MB大小的对象，然后不发生GC直接在老年代分配4MB大小的对象，执行代码结果如下：

![大对象直接分配在老年代](C:\Users\Administrator\Desktop\学习\java\Java-learn\Java虚拟机\img\大对象直接分配在老年代.PNG)

​	与上节截图对比高亮部分，就可以得出理论正确的结果。

> `-XX：PretenureSizeThreshold`参数只对**Serial**和**ParNew**两款新生代收集器有效，HotSpot的其他新生代收集器，如Parallel Scavenge并不支持这个参数。如果必须使用此参数进行调优，可考虑ParNew加CMS的收集器组合。



## 空间分配担保