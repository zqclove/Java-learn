# 类加载子系统

# 概述

类加载器是 JVM 的重要组成部分，被用于加载类和接口。为方便 Java开发人员的日常工作，无需自定义类加载器，JVM已经为开发人员写好了可用的类加载器。当然，如果为了满足某些需求，也可自定义类加载器。例如Tomcat容器，Tomcat为每个Web应用程序创建一个类加载器（这样它就可以卸载Web应用程序并释放内存）。

# 什么是类加载器

​	Java程序是在 JVM 中运行。当我们编译一个 Java 类时，它会被转换为一个独立于平台与机器的字节码文件。当我们试图使用一个类时，Java 类加载器会将这个类加载到内存中。当在一个已经运行的类中按名称引用时，类会被引入 Java 环境。在第一个类运行之后，类装入器将尝试装入类。运行第一个类通常是通过声明和使用静态main()方法来完成的。

[![hierarchy of class loaders](https://javatutorial.net/wp-content/uploads/2017/10/hierarchy-of-class-loaders.png)](https://javatutorial.net/wp-content/uploads/2017/10/hierarchy-of-class-loaders.png)



# 类加载器类型

**从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：**

- 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；
- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。

**从 Java 开发人员的角度看，类加载器可以划分得更细致一些：**

1. **启动类加载器（Bootstrap ClassLoader）：**

    ​	此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath  参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib  目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java  程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。

2. **扩展类加载器（Extension ClassLoader）：**

    ​	这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将<JAVA_HOME>/lib/ext 或者被 java.ext.dir  系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。

3. **系统类加载器（System ClassLoader/Application ClassLoader）：**

    ​	这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是  ClassLoader 中的 getSystemClassLoader()  方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，这些类可以在使用 -cp 或 -classpath 命令行选项调用程序时设置。开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

4. **自定义加载器（User ClassLoader）：**

    ​	负责加载用户自定义路径下的类包。

# 双亲委派模型

应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。

下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation  Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。

 [![img](https://camo.githubusercontent.com/069d7ec7d8d131fe148a3fc42eb1a27335e0aa0d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30646432643430612d356232622d346434352d623137362d6537356134636434626462662e706e67)](https://camo.githubusercontent.com/069d7ec7d8d131fe148a3fc42eb1a27335e0aa0d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30646432643430612d356232622d346434352d623137362d6537356134636434626462662e706e67) 

## 1. 工作过程

一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。

## 2. 好处

使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到  ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的  Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object  使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。

## 3. 实现

以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass()  方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出  ClassNotFoundException，此时尝试自己去加载。

用指定的二进制名称加载类。该方法的默认实现按以下顺序搜索类:

1. 调用findLoadedClass(字符串)检查类是否已经加载。
2. 调用父类装入器上的loadClass方法。如果父类为null，则使用虚拟机内置的类加载器（启动类加载器）。
3. 调用findClass(字符串)方法来查找类（调用子类重写的findClass方法）。

如果使用上述步骤找到类，并且解析标志为true，则此方法将在生成的类对象上调用resolveClass(类)方法。

类加载器的子类鼓励重写findClass(字符串)，而不是这个方法。

除非被覆盖，否则该方法在整个类加载过程中同步getClassLoadingLock方法的结果。

```java
public abstract class ClassLoader {
    // The parent class loader for delegation
    private final ClassLoader parent;

    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }

    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name); // 让虚拟机内置启动类加载该类
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c); // 连接该类
            }
            return c;
        }
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}
```

# 自定义类加载器实现

以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自  java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class  文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。

java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。

```java
public class FileSystemClassLoader extends ClassLoader {

    private String rootDir;

    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classData = getClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            return defineClass(name, classData, 0, classData.length);
        }
    }

    private byte[] getClassData(String className) {
        String path = classNameToPath(className);
        try {
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String classNameToPath(String className) {
        return rootDir + File.separatorChar
                + className.replace('.', File.separatorChar) + ".class";
    }
}
```

**注意：**一个功能良好的类加载器应当保证以下三点属性：

- 给定相同的类名称，类加载器应当总是返回相同的Class（类型）对象。
- 如果类加载器 *L1* 将加载类 *C* 的请求委托给另一个类加载器 *L2* ，那么对于满足下列条件之一的任意类型 *T* 来说，*L1* 和 *L2* 都应当返回相同的 Class 对象（加载 *C* 属性相关）：
    - *T* 是 *C* 的直接超类或直接超接口；
    - *T* 是 *C* 中某个字段的类型；
    - *T* 是 *C* 中某个方法或构造器的形式参数类型；
    - *T* 是 *C* 中某个方法的返回值类型；
- 如果某个用户自定义的类加载器预先加载了某个类或接口的二进制表示，或批量加载了一组相关的类，并在加载时出现错误，那它就必须在程序的某个点反映出加载时的错误。而这个点，一定要和不使用预先加载或批量加载时出现错误的那个点相同。

# 类的加载时间和方式

类的加载时间有两种情况：

1. 当执行新的字节码时(例如，MyClass mc = new MyClass()）；
2. 当字节码对类(例如System.out)进行静态引用时；

类加载器是分层的。第一个类是通过类（主类）中声明的静态main()方法特别加载的。所有随后加载的类都由已经加载并正在运行的类加载。

类加载器在加载类时遵循一下规则（双亲委托机制）：

1. 检查类是否已经加载；
2. 如果未加载，委托父类加载器去加载该类；
3. 如果父类加载器无法加载该类，则尝试自身加载器加载该类；

**双亲委托机制的优势：**

- 沙箱安全机制：比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改；
- 避免类重复加载：当父加载器已经加载了该类时，就不需要子类再加载一次；

# 静态加载与动态加载

​	类是用Java的new操作符静态加载的。动态加载是一种技术，通过使用class . forname()在运行时以编程方式调用类加载器的函数。

​	类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。

# loadClass与Class.forname之间的不同

​	**loadClass**只加载类但不初始化对象；

​	**Class.forname**会在加载类后初始化对象；

例子：如果你使用ClassLoader.loadClass去加载 JDBC 驱动类，该类不会被注册，并且程序也无法使用 JDBC。

# 类的生命周期

 [![img](https://camo.githubusercontent.com/7fcef0cbcfc984a6b4de3bb3b8a333e5b254e31c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333566653139632d346137362d343561622d393332302d3838633930643661306437652e706e67)](https://camo.githubusercontent.com/7fcef0cbcfc984a6b4de3bb3b8a333e5b254e31c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333566653139632d346137362d343561622d393332302d3838633930643661306437652e706e67) 

包括以下 7 个阶段：

- **加载（Loading）**
- **验证（Verification）**
- **准备（Preparation）**
- **解析（Resolution）**
- **初始化（Initialization）**
- 使用（Using）
- 卸载（Unloading）

# 类的加载过程

包含了加载、验证、准备、解析和初始化这 5 个阶段。

## 加载（Loading）

加载是类加载的一个阶段，注意不要混淆。

加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的二进制字节流。
- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

## 链接（Linking）

​	连接包括三个步骤：

- 验证：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

- 准备：类变量是被 static 修饰的变量（包含方法、字段和类），准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。

    实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

    初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

    ```java
    public static int value = 123;
    ```

    如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。

    ```java
    public static final int value = 123;
    ```

- 解析：将常量池的符号引用替换为直接引用的过程。

    **其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。**

## 初始化（Initialization）

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

<clinit>()  是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，**静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。**例如以下代码：

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>()  方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>()  方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>()  方法。

虚拟机会保证一个类的 <clinit>()  方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>()  方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>()  方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。

# 类初始化时机

## 1. 主动引用

虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：

- 遇到 new、getstatic、putstatic、invokestatic  这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new  关键字实例化对象的时候；读取或设置一个类的静态字段（**被 final  修饰、已在编译期把结果放入常量池的静态字段除外**）的时候；以及调用一个类的静态方法的时候。
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为  REF_getStatic, REF_putStatic, REF_invokeStatic  的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；

简而言之：在new、读取或设置静态字段、调用类的静态方法、反射调用、初始化类（先触发父类的初始化）、初始化主类（包含main（）方法）时，如果发现类没有初始化，则需要先初始化类。



```java
public class InitializationTest {

    static {
        System.out.println("static");
    }

    public static void main(String[] args) {
        System.out.println("main");
    }
}
//主类在虚拟机启动时初始化。
```



## 2. 被动引用

以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：

- 通过子类引用父类的静态字段，不会导致子类初始化。

```java
System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
```

- 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。

```java
SuperClass[] sca = new SuperClass[10];
```

- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

```java
System.out.println(ConstClass.HELLOWORLD);
```

# 类相等与类加载器的关系

两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。

这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。

# Java虚拟机规范中加载、链接与初始化

## 创建和加载

​	（同一规范：*C* ：类或接口， *N* ：类或接口 *C* 的标记（类或接口二进制名称），*L* ：用户自定义类加载器）

​     Java虚拟机启动是通过启动类加载器创建一个初始类来完成的，该类加载器是虚拟机使用c++具体实现的。接着，虚拟机连接这个初始类，初始化并调用它的静态 main 方法。之后的整个执行过程都是对此方法的调用开始的。在执行main方法中的虚拟机指令可能会导致虚拟机连接（并于其后创建）另外的一些类或接口，也可能会令虚拟机调用另外的方法。

​	如果要创建标记为 *N* 的类或接口 *C*，需要现在虚拟机方法区上为 *C* 创建与虚拟机实现相匹配的内部表示。*C* 的创建是由另一个类或接口 *D* 所出发的，它通过自己的运行时常量池引用了 *C*。*C* 的创建也可能由 *D* 调用 JavaSE平台类库中的某些方法而出发，如反射等。

​	在虚拟机运行时，类或接口是由键值对的形式确定：二进制名称和它的定义加载器共同确定的。有时使用 < *N*，*L* > 来表示一个类或接口。

​	如果类加载器直接创建某个类或接口，这个类加载器被称为该类或接口的**定义加载器**。

​	如果类加载器把加载请求委托给其他的类加载器，这个类加载器被成为该类或接口的**初始加载器**。

​	**Java虚拟机通过下面三个过程之一来创建标记为 *N* 的类或接口 *C* ：**

- 如果 *N* 表示一个非数组的类或接口，那么可以用以下两种方式来加载并创建 *C* ：
    - 如果 *D* 是由启动类加载器所定义的，那么用启动类加载器来初始加载 *C* 。
    - 如果 *D* 是由用户自定义加载器所定义的，那么用该自定义加载器来初始加载 *C* 。
- 如果 *N* 表示一个数组类，那么该数组类是由虚拟机而不是类加载器创建。然而，在创建数组类 *C* 的过程中，也会用到 *D* 的定义类加载器。

### 使用引导类加载器来加载类型

​	首先，虚拟机检查引导类加载器是否已标注成用 *N* 来表示的非数组类或接口的初始加载器。

​	如是，那么这个类或接口就是 *C* ，并且无需再创建类了。

​	如果不是，虚拟机将参数 *N* 传递给引导类加载器的特定方法，以平台相关的方式搜索 *C* 的描述（全限定名的方式搜索 **.*class*** 文件）。如果在搜索过程中未找到该描述或该描述不是对 *C* 的描述，则抛出 ClassNotFoundException的实例。

​	之后则根据 ***从class文件表示得到类*** 小节的算法，尝试通过引导类加载器来加载标识为 *N* 的描述，加载完成的类就是 *C* 。

### 使用用户自定义类加载器来加载类型

​	首先，虚拟机检查自定义类加载器 *L* 是否已经标注为 *N* 所表示的类或接口的初始加载器。

​	如是，那么这个类或接口就是 *C* ，不再创建。

​	否则，虚拟机会调用 *L* 的 loadClass( *N* ) 方法。这次调用的返回值就是创建好的类或接口 *C* 。虚拟机会记录下 *L* 是 *C* 的初始加载器（见 ***加载限制*** 小节）。

​	当通过 *C* 的名称 *N* 去调用 *L* 的 loadClass 方法时，*L* 必须执行下面两种操作之一来加载 *C* ：

1. 类加载器 *L* 可以通过创建一个如 ClassFile 结构（见 Java虚拟机规范4.1节）的字节数组来表示 *C* ；然后必须调用 ClassLoader 的 defineClass 方法。调用 defineClass 方法会让虚拟机使用 ***从class文件表示得到类***  小节的算法通过 *L* 由字节数组得到标记为 *N* 的类或接口 *C* 。
2. 类加载器 *L* 可能把对 *C* 的加载请求委托给其他类加载器 *L‘* 。这是通过直接或简介传递参数 *N* 来调用 *L’* 的方法（一般是loadClass方法）而完成的。这次调用会产生 *C*。

无论何种方式，只要类加载器由于任何原因不能加载标识为 *N* 的类或接口，那么它就必须抛出 ClassNotFoundException 异常。

### 创建数组类

​	使用类加载器 *L* 来创建标记为 *N* 的数组类 *C* 的过程如下所示，其中类加载器 *L* 可以是引导类加载器或用户自定义类加载器。

​	如果 *L* 已经被虚拟机记录成某个与 *N* 有相同元素类型的数组类的初始加载器，那么类就是 *C* ，不再创建新的数组类。（即已经加载过该数组类）

​	否则创建 *C* 的过程遵循以下步骤：

1. 如果组件类型是引用类型，那就在类加载器 *L* 上面递归运用本节算法，以加载和创建 *C* 的组件类型。
2. 虚拟机使用指定的组件类型（基础数据类型）和数组维度来创建新的数组类型，把数组类 *C* 标记为被引导类加载器定义过。

​	如果组件类型是引用类型，那就把 *C* 标记为它已经被该组件类型的定义类加载器定义过。否则，就把 *C* 标记为它被引导类加载器定义过。

​	不管哪种情况，虚拟机都会把 *L* 记录为 *C* 的初始加载器。

​	如果数组的组件类型是引用类型，那么数组类的可访问性就有组件类型的可访问性决定，否则可访问性默认为public。

***自我思考：*** 

​	数组是由虚拟机直接创建而不是类加载器，这里的创建数组类指得是创建数组元素的类型。

​	组件类型是数组类型最外面那一维元素的类型。一个数组的组件类型也可以是数组，此时就取这个小数组的组件类型，直到组件类型不是数组类型，就把这种类型成为本数组类型的元素类型。

### 加载限制

​	类加载器需要特别考虑类型的安全链接问题。一种可以能出现的情况是，当两个不同的类加载器初始加载相同标记为 *N* 的类或接口时，每个加载器中的 *N* 表示的不是同一个类或接口（类或接口由二进制名称和加载器共同确定）。

​	当类或接口 *C* = <N1,L1> 含有指向另一个类或接口 *D* = <N2,L2> 的字段或方法的符号引用时，这个符号引用会包含表示字段类型，或方法参数和返回值类型的描述符。重要的是：字段或方法描述符里提到的任意类型名称 *N* ,无论是由 L1 加载还是 L2 加载，其结果都应该表示同一个类或接口（见 ***自定义类加载器实现*** 小节中的注意事项）。

​	为了确保这一原则，虚拟机在***准备*** 和***解析*** 阶段会强制实施 “<N,L1>=<N,L2>” 形式的**加载约束**。为了强制实施这个约束，虚拟机会在某些关键点（**创建和加载**阶段）把特定的加载器记录为特定类的初始加载器。在记录下一个加载器是某个类的初始加载器后，虚拟机会立即检查是否违反了这一约束。如果发生违约情况，将撤销这次记录，虚拟机会抛出 LinkageError，而导致记录产生的那次加载操作也同样失效。

​	与之相似的，在强制执行加载约束（**准备和解析**阶段）之后，虚拟机也必须立即检查是否有违约情况发生。如果有，那么最新的那个加载约束就会被撤销，虚拟机会抛出 LinkageError 异常，引入约束（可能在解析或准备阶段，视情况而定）的那些操作也会失败。

​	本小节所描述的这个时机，就是虚拟机能够检查加载约束是否遭到违反的唯一时机。当且仅当以下四个条件满足时，才算违反了加载约束：

- 类加载器 *L* 被虚拟机记录为由 *N* 所表示的类 *C* 的初始加载器；
- 类加载器 *L’* 被虚拟机记录为由 *N* 所表示的类 *C‘* 的初始加载器；
- 由施加的约束集（或者说，约束集的传递闭包）所定义的等价关系，意味着 <N,L>=<N,L’> 。
- C ≠ C‘ 。

以上条件简而言之就是：两个不同的类加载器作为相同标记为 *N* 的类或接口的初始加载器，在准备和解析阶段被施加加载约束，但类或接口 *C* 不等于 *C’* 。

### 从class文件表示得到类

​	以下步骤是描述类加载器 *L* 从 ***.class*** 文件的描述中得到标记为 *N* 的非数组类或接口 *C* 的 Class 对象。

1. 首先，虚拟机检查 *L* 是否已经被记录为由 *N* 所表示的类或接口的初始加载器。如果是，那么这次创建的尝试动作是无效的，且加载动作抛出LinkageError异常。

2. 如果不是，虚拟机尝试解析二进制表示。但是，这个二进制表示可能不是 *C* 的有效描述。这个阶段的加载动作必须能够检测出下列错误：

    - 如果发现这个正在加载的描述不符合 ***ClassFile*** 结构（见 Java虚拟机规范 4.1节和4.8节），那么加载过程将抛出ClassFormatError异常。
    - 符合 ***ClassFile*** 结构的话，如果这份二进制表示里的主版本号或副版本号不受虚拟机支持，那么加载动作就会抛出UnspportedClassVersionError异常。

    ```
    UnspportedClassVersionError异常是ClassFormatError的子类，可以轻易地从ClassFormatError异常中区分那些在尝试加载某个类时，因该类的数据所使用的Class文件格式版本不受支持而引发的错误。
    ```

    - 版本号受虚拟机支持的话，如果该描述不能真正表示名称为 *N* 的类，那么加载过程就会抛出NoClassDefError异常或其子类的异常。

3. 如果 *C* 有一个直接父类，那么由 *C* 到直接父类的符号引用就需要 ***类与接口解析（位于链接的解析节中）*** 小节描述的算法来解析。需要注意的是，如果 *C* 是一个接口，那它必须以Object作为直接父类，而Object必定已经被加载过。只有Object类才没有自己的直接父类。

    ​	类或接口解析过程中的异常可以被当做这一加载阶段中的异常而抛出。除此之外，加载阶段还必须可以检查以下错误：

    - 如果类或接口 *C* 的直接父类事实上是一个接口，那么加载过程就必须抛出 IncompatibleClassChangeError异常（不兼容）。
    - 否则，如果 *C* 的父类是 *C* 自己，那么加载过程就必须抛出ClassCircularityError异常（循环）。

4. 如果 *C* 有一写直接父接口，那么由 *C* 到它的直接父接口的符号引用就需要使用 ***类与接口解析（位于解析节中）*** 小节描述的算法来解析。

    ​		类或接口解析过程中的异常可以被当做这一加载阶段中的异常而抛出。除此之外，加载阶段还必须可以检查以下错误：

    - 如果类或接口 *C* 的直接父接口事实上不是一个接口，那么加载过程就必须抛出 IncompatibleClassChangeError异常（不兼容）。
    - 否则，如果 *C* 的某个父接口是 *C* 自己，那么加载过程就必须抛出ClassCircularityError异常（循环）。

5. 虚拟机标记 *C* 的定义类加载器是 *L* ，并且记录下 *L* 是 *C* 的初始加载器。

## 链接

​	链接类或接口包括验证和准备类或接口、它的直接父类、它的直接父接口、它的元素类型（如果是一个数组类型）。而解析这个类或接口的引用符号则是链接过程中的可选部分（解析与初始化交换顺序实现动态绑定）。

​	虚拟机规范允许灵活地选择链接（及由于递归链接而引发的加载）时机，但必须保证下列几点成立：

- 在类或接口被连接之前，它必须被成功地加载过。

- 在类或接口初始化之前，它必须被成功地验证及准备过。

- 若程序执行了某种可能需要直接或简介链接一个类或接口的动作，而在链接该类或接口的过程中又检测到了错误，则错误的抛出点应是执行动作的那个点。

    ​	例如，虚拟机实现可以在用到类或接口的符号引用时才去逐一解析它（延迟解析），或者在验证类的时候就解析每个引用（预先解析）。这意味着在一些虚拟机实现中，当类或接口初始化之后，解析动作可能还在进行。不管采用哪种策略，解析过程中的任何错误都必须抛出，抛出的位置是在通过直接或间接使用符号引用而导致解析过程发生的程序处。

    ​	由于链接过程会涉及新数据结构的内存分配，因此它可能因为发生OutOfMemoryError异常而导致失败。

    ***自我思考*** ：链接时机主要体现在延迟解析和预先解析，延迟解析即交换解析和初始化的顺序实现动态绑定。

### 验证

​	验证（见Java虚拟机规范中 4.10小节class文件校验）阶段用于确保类或接口的二进制表示在结构上是正确的（见4.9节 代码约束）。验证过程可能会导致某些额外的类或接口被加载进来，但不一定会导致它们也需要验证或准备。

​	如果类或接口的二进制表示不能满足 4.9节（代码约束） 中描述的静态或结构上的约束，那就必须在导致验证发生的程序出抛出 VerifyError异常。

​	如果 Java 虚拟机尝试验证类或接口，却因为抛出了 LinkageError或其子类的实例而导致验证失败，那么随后对于此类或接口的验证尝试，就总是会由于与第一次尝试失败相同的原因而失败。（类加载器 *L* 已被记录为由 *N* 所表示的类或接口 *C* 的初始加载器，在加载时则会抛出 LinkageError） 

### 准备

​	准备阶段的任务是创建类或接口的静态字段，并用默认值初始化这些字段。这个阶段不会执行任何的虚拟机字节码指令。在初始化阶段会有显式的初始化器来初始化这些静态字段，所以准备阶段不做这些事情。

​	在某个类或接口 *C* 的准备阶段，虚拟机也会有强制实施加载约束。假定 *L1* 是 *C* 的定义加载器。对于每个声明在 *C* 中的方法 *m* 来说，如果它覆盖了声明在 *C* 的父类或父接口 <D,L2>中的某个方法，那么虚拟机强制执行下面的加载约束：

```
	给定的 *m* 的返回值类型是 *Tr* ，并且给定 *m* 的形参类型从 *Tf1*，.....，*Tfn*，则如果 *Tr* 不是数组类型，那么用 *To* 代替 *Tr* ；不然的话 *To* 就表示 *Tr* 的元素类型。

	对于从1到n的每个 i 来说，如果 *Tfi* 不是数组类型，那么 *Ti* 表示 *Tfi* ；不然， *Ti* 就是 *Tfi* 的元素类型。

	对于从0到n的每个 i 来说，<Ti，L1> = <Ti，L2 >都应该成立（即方法的返回值类型和参数类型的加载被实施加载约束）。
```

​	此外，如果 *C* 实现了它的父接口< I，L3 >中的方法 *m* ，但 *C* 自己却没有声明这个方法 *m* ，那么就把声明了有 *C* 所继承的方法 *m* 实现的那个超类记为<D，L2>。虚拟机强制施加如下约束：

```
	给定的 *m* 的返回值类型是 *Tr* ，并且给定 *m* 的形参类型从 *Tf1*，.....，*Tfn*，如果 *Tr* 不是数组类型，那么用 *To* 代替 *Tr* ；不然的话 *To* 就表示 *Tr* 的元素类型。

	对于从1到n的每个 i 来说，如果 *Tfi* 不是数组类型，那么 *Ti* 表示 *Tfi* ；不然， *Ti* 就是 *Tfi* 的元素类型。

	对于从0到n的每个 i 来说，<Ti，L2> = <Ti，L3 >都应该成立（即方法的返回值类型和参数类型的加载被实施加载约束）。
```

​	在创建好类之后的任何时间，都可以进行准备，但一定要保证在初始化阶段开始前完成。

### 解析

​	虚拟机指令 ***anewarray*** 、***checkcast*** 、***getfiled*** 、***getstatic*** 、***instanceof*** 、***invokedynamic*** 、***invokeinterface*** 、***invokespecial*** 、***invokestatic*** 、***invokevirtual*** 、***ldc*** 、***ldc_w*** 、***multianewarray*** 、***new*** 、***putfield*** 和 ***putstatic*** 将符号引用指向运行时常量池。执行上述任何一条指令都需要对它的符号引用进行解析。

​	**解析是根据运行时常量池的符号引用来动态决定具体值的过程。**

​	当碰到一次 ***invokedynamic*** 指令而去解析它的符号引用后，并不意味着对于其他 ***invokedynamic*** 指令来说，相同的符号引用也被解析过（即每个 ***invokedynamic*** 独立解析它的符号引用）。

​	但是对于上述其他指令来说，当碰到这个指令并解析它的符号引用后，就表示对于其他的非 ***invokedynamic*** 指令来说，相同的符号引用已经被解析过了。

​	（上面内容暗示：由特定的 ***invokedynamic*** 指令的解析结果所决定的那个具体值，是一个绑定到该 ***invokedynamic*** 指令的调用点对象）

​	解析过程也可以尝试去重新解析之前成功解析过的符号引用。这样的尝试动作总是像之前一样成功，并且总是返回与此引用初次解析的结果相同的实体。

​	如果在解析某个符号引用时发生错误，则应该在（直接或间接）使用该符号引用的程序处抛出 IncompatibleClassChangeError或它的子类异常。

​	如果在虚拟机解析符号引用时，因为LinkageError或它的子类实例而导致失败，那么随后解析此引用时，都会抛出与第一次解析时相同的错误。

​	对于由 ***invokedynamic*** 指令所指定的调用点限定符来说，指向该限定符的符号引用，在执行那个指令之前不能提前解析。

​	如果解析某个 ***invokedynamic*** 指令的时候出错，那么引导方法在随后尝试解析时就不再重新执行了。

​	上述某些指令在解析符号引用时，需要有额外的链接检查，例如 ***getfield*** 指令为了成功解析指向该指令所需要操作的那个字段的符号引用，不仅需要完成 ***字段解析*** 步骤，而且还需要检查该字段是不是static的。如果是static的，那就必须抛出链接时异常。

​	尤其注意的是：为了让 ***invokedynamic*** 指令成功解析某个调用点限定符的符号引用，指定的引导方法必须正常完成并返回一个合适的调用点对象。如果引导方法被打断或返回了一个不合适的调用点对象，那么也必须抛出链接时异常。

​	下面描述对于类或接口 *D* 的运行时常量池里的符号引用进行解析的过程。解析细节会因为符号引用种类的不同而有所不同。

#### 类与接口解析

​	虚拟机为了解析 *D* 中对标记为 *N* 的类或接口 *C* 的未解析符号引用，会执行如下步骤：

1. *D* 的定义类加载器被用来创建标记为 *N* 的类或接口。这个类或接口是 *C* 。（此过程即 ***创建和加载*** ）

    创建类或接口时所抛出的异常，可以当成因解析类或接口失败所导致的异常而抛出。

2. 如果 *C* 是数组类且它的元素类型是引用类型，那么指向表示元素类型的类或接口的符号引用会按照此算法来递归解析。

3. 最后，检查 *C* 的访问权限：

    ​	如果 *C* 对 *D* 是不可见的，那么类或接口的解析会抛出 IllegalAccessError。

    ``` 
    这种情况有可能发生，例如，C是一个原来声明为public的类，但它在D编译后被改成非public
    ```

    如果第1步和第2步成功但是第3步失败，那么 *C* 仍然是有效且可用的。但解析是失败的，而且 *D* 不能访问 *C* 。

#### 字段解析

​	如果要解析从 *D* 指向类或接口 *C* 中的某个字段的未解析符号引用，那么必须先解析指向该字段引用所提到的那个 *C* 的符号引用（见***类与接口解析***）。因此，在解析类或接口引用时发生的任何异常都可以当做解析字段引用的异常抛出。如果指向 *C* 的引用成功解析，那么可以抛出解析字段引用本身时发生的异常。

​	当解析字段引用时，字段解析过程会先尝试在 *C* 和它的父类查找这个字段：

1. 如果 *C* 中声明的某个字段，与字段引用有相同的名称及描述符，那么此次查找成功。字段查找的结果就是 *C* 中那个声明的字段。

2. 否则，字段查找过程会递归地应用到类或接口 *C* 的直接父接口上。

3. 否则，如果 *C* 有一个父类 *S* ，那么字段查找会递归应用到 *S* 上。

4. 如果还未找到，则字段查找失败。

    然后：

    - 如果字段查找失败，字段解析过程会抛出 NoSuchFieldError。
    - 否则，如果字段查找成功，但是引用的那个字段对 *D* 是不可见的，那么字段解析会抛出 IllgalAccessError异常。
    - 否则，假设<E,L1>是真正声明所引用字段的那个类或接口，*L2* 是 *D* 的定义加载器。给定引用字段的类型是 *Tr* ，那么当 *Tf* 是非数组类型时，*T=Tf*，而当 *Tf* 是数组时，*T* 是它的元素类型。虚拟机必须强制实施加载约束：<T，L1>=<T，L2>。

## 普通方法解析

​	

## 访问控制





## 方法覆盖



# ClassLoader源码分析

## defineClass方法

​	将字节码数组转换成类类型的实例，该类型在使用前必须要对其进行链接。

​	此方法将一个默认ProtectionDomain分配给新定义的类。ProtectionDomain被有效地授予与Policy.getPolicy().getPermissions(new CodeSource(null, null)) 被调用时返回的权限集相同的权限。默认域是在第一次调用defineClass时创建的，并在后续调用中重用。

​	要将特定的ProtectionDomain分配给类，请使用将ProtectionDomain作为其参数之一的defineClass方法。

```java
    protected final Class<?> defineClass(String name, byte[] b, int off, int len)
        throws ClassFormatError
    {
        return defineClass(name, b, off, len, null);
    }
```

