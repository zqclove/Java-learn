[TOC]

# Java虚拟机

Java设计理念是“write once，run anywhere”。

Java编译器将 Java源文件 - A.java文件编译成 Java字节码文件 - A.class文件。.class文件由 JVM 进行解释。

[![Run Java bytecode on different platforms - the "write once, run anywhere" concept](https://javatutorial.net/wp-content/uploads/2017/10/write-once-run-anywhere-jvm.png)](https://javatutorial.net/wp-content/uploads/2017/10/write-once-run-anywhere-jvm.png)

​	字节码是 Java 和 机器语言之间的中间语言。相同的字节码文件可以被任何 JVM 实现上执行，不需要因为平台不同而调整代码。

## Java虚拟机架构

JVM 主要由三个子系统组成：

- 类加载器子系统
- 运行时数据区
- 执行引擎

[![Java Virtual Machine architecture diagram ](https://javatutorial.net/wp-content/uploads/2017/10/jvm-architecture-992x1024.png)](https://javatutorial.net/wp-content/uploads/2017/10/jvm-architecture.png)



# 类加载子系统

## 概述

类加载器是 JVM 的重要组成部分，被用于加载类和接口。为方便 Java开发人员的日常工作，无需自定义类加载器，JVM已经为开发人员写好了可用的类加载器。当然，如果为了满足某些需求，也可自定义类加载器。例如Tomcat容器，Tomcat为每个Web应用程序创建一个类加载器（这样它就可以卸载Web应用程序并释放内存）。

## 什么是类加载器

​	Java程序是在 JVM 中运行。当我们编译一个 Java 类时，它会被转换为一个独立于平台与机器的字节码文件。当我们试图使用一个类时，Java 类加载器会将这个类加载到内存中。当在一个已经运行的类中按名称引用时，类会被引入 Java 环境。在第一个类运行之后，类装入器将尝试装入类。运行第一个类通常是通过声明和使用静态main()方法来完成的。

[![hierarchy of class loaders](https://javatutorial.net/wp-content/uploads/2017/10/hierarchy-of-class-loaders.png)](https://javatutorial.net/wp-content/uploads/2017/10/hierarchy-of-class-loaders.png)



## 类加载器类型

**从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：**

- 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；
- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。

**从 Java 开发人员的角度看，类加载器可以划分得更细致一些：**

1. **启动类加载器（Bootstrap ClassLoader）：**

   ​	此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath  参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib  目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java  程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。

2. **扩展类加载器（Extension ClassLoader）：**

   ​	这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将<JAVA_HOME>/lib/ext 或者被 java.ext.dir  系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。

3. **系统类加载器（System ClassLoader/Application ClassLoader）：**

   ​	这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是  ClassLoader 中的 getSystemClassLoader()  方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，这些类可以在使用 -cp 或 -classpath 命令行选项调用程序时设置。开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

4. **自定义加载器（User ClassLoader）：**

   ​	负责加载用户自定义路径下的类包。

## 双亲委派模型

应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。

下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation  Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。

 [![img](https://camo.githubusercontent.com/069d7ec7d8d131fe148a3fc42eb1a27335e0aa0d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30646432643430612d356232622d346434352d623137362d6537356134636434626462662e706e67)](https://camo.githubusercontent.com/069d7ec7d8d131fe148a3fc42eb1a27335e0aa0d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30646432643430612d356232622d346434352d623137362d6537356134636434626462662e706e67) 

### 1. 工作过程

一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。

### 2. 好处

使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到  ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的  Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object  使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。

### 3. 实现

以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass()  方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出  ClassNotFoundException，此时尝试自己去加载。

用指定的二进制名称加载类。该方法的默认实现按以下顺序搜索类:

1. 调用findLoadedClass(字符串)检查类是否已经加载。
2. 调用父类装入器上的loadClass方法。如果父类为null，则使用虚拟机内置的类加载器（启动类加载器）。
3. 调用findClass(字符串)方法来查找类（调用子类重写的findClass方法）。

如果使用上述步骤找到类，并且解析标志为true，则此方法将在生成的类对象上调用resolveClass(类)方法。

类加载器的子类鼓励重写findClass(字符串)，而不是这个方法。

除非被覆盖，否则该方法在整个类加载过程中同步getClassLoadingLock方法的结果。

```java
public abstract class ClassLoader {
    // The parent class loader for delegation
    private final ClassLoader parent;

    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }

    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name); // 让虚拟机内置启动类加载该类
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c); // 连接该类
            }
            return c;
        }
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}
```

## 自定义类加载器实现

以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自  java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class  文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。

java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。

```java
public class FileSystemClassLoader extends ClassLoader {

    private String rootDir;

    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classData = getClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            return defineClass(name, classData, 0, classData.length);
        }
    }

    private byte[] getClassData(String className) {
        String path = classNameToPath(className);
        try {
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String classNameToPath(String className) {
        return rootDir + File.separatorChar
                + className.replace('.', File.separatorChar) + ".class";
    }
}
```

**注意：**一个功能良好的类加载器应当保证以下三点属性：

- 给定相同的类名称，类加载器应当总是返回相同的Class（类型）对象。
- 如果类加载器 *L1* 将加载类 *C* 的请求委托给另一个类加载器 *L2* ，那么对于满足下列条件之一的任意类型 *T* 来说，*L1* 和 *L2* 都应当返回相同的 Class 对象（加载 *C* 属性相关）：
  - *T* 是 *C* 的直接超类或直接超接口；
  - *T* 是 *C* 中某个字段的类型；
  - *T* 是 *C* 中某个方法或构造器的形式参数类型；
  - *T* 是 *C* 中某个方法的返回值类型；
- 如果某个用户自定义的类加载器预先加载了某个类或接口的二进制表示，或批量加载了一组相关的类，并在加载时出现错误，那它就必须在程序的某个点反映出加载时的错误。而这个点，一定要和不使用预先加载或批量加载时出现错误的那个点相同。

## 类的加载时间和方式

类的加载时间有两种情况：

1. 当执行新的字节码时(例如，MyClass mc = new MyClass()）；
2. 当字节码对类(例如System.out)进行静态引用时；

类加载器是分层的。第一个类是通过类（主类）中声明的静态main()方法特别加载的。所有随后加载的类都由已经加载并正在运行的类加载。

类加载器在加载类时遵循一下规则（双亲委托机制）：

1. 检查类是否已经加载；
2. 如果未加载，委托父类加载器去加载该类；
3. 如果父类加载器无法加载该类，则尝试自身加载器加载该类；

**双亲委托机制的优势：**

- 沙箱安全机制：比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改；
- 避免类重复加载：当父加载器已经加载了该类时，就不需要子类再加载一次；

## 静态加载与动态加载

​	类是用Java的new操作符静态加载的。动态加载是一种技术，通过使用class . forname()在运行时以编程方式调用类加载器的函数。

​	类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。

## loadClass与Class.forname之间的不同

​	**loadClass**只加载类但不初始化对象；

​	**Class.forname**会在加载类后初始化对象；

例子：如果你使用ClassLoader.loadClass去加载 JDBC 驱动类，该类不会被注册，并且程序也无法使用 JDBC。

## 类的生命周期

 [![img](https://camo.githubusercontent.com/7fcef0cbcfc984a6b4de3bb3b8a333e5b254e31c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333566653139632d346137362d343561622d393332302d3838633930643661306437652e706e67)](https://camo.githubusercontent.com/7fcef0cbcfc984a6b4de3bb3b8a333e5b254e31c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333566653139632d346137362d343561622d393332302d3838633930643661306437652e706e67) 

包括以下 7 个阶段：

- **加载（Loading）**
- **验证（Verification）**
- **准备（Preparation）**
- **解析（Resolution）**
- **初始化（Initialization）**
- 使用（Using）
- 卸载（Unloading）

## 类的加载过程

包含了加载、验证、准备、解析和初始化这 5 个阶段。

### 加载（Loading）

加载是类加载的一个阶段，注意不要混淆。

加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的二进制字节流。
- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

### 链接（Linking）

​	连接包括三个步骤：

- 验证：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

- 准备：类变量是被 static 修饰的变量（包含方法、字段和类），准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。

  实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

  初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

  ```java
  public static int value = 123;
  ```

  如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。

  ```java
  public static final int value = 123;
  ```

- 解析：将常量池的符号引用替换为直接引用的过程。

  **其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。**

### 初始化（Initialization）

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

<clinit>()  是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，**静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。**例如以下代码：

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>()  方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>()  方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>()  方法。

虚拟机会保证一个类的 <clinit>()  方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>()  方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>()  方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。

## 类初始化时机

### 1. 主动引用

虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：

- 遇到 new、getstatic、putstatic、invokestatic  这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new  关键字实例化对象的时候；读取或设置一个类的静态字段（**被 final  修饰、已在编译期把结果放入常量池的静态字段除外**）的时候；以及调用一个类的静态方法的时候。
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为  REF_getStatic, REF_putStatic, REF_invokeStatic  的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；

简而言之：在new、读取或设置静态字段、调用类的静态方法、反射调用、初始化类（先触发父类的初始化）、初始化主类（包含main（）方法）时，如果发现类没有初始化，则需要先初始化类。



```java
public class InitializationTest {

    static {
        System.out.println("static");
    }

    public static void main(String[] args) {
        System.out.println("main");
    }
}
//主类在虚拟机启动时初始化。
```



### 2. 被动引用

以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：

- 通过子类引用父类的静态字段，不会导致子类初始化。

```java
System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
```

- 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。

```java
SuperClass[] sca = new SuperClass[10];
```

- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

```java
System.out.println(ConstClass.HELLOWORLD);
```

## 类相等与类加载器的关系

两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。

这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。

## Java虚拟机规范中加载、链接与初始化

### 创建和加载

​	（同一规范：*C* ：类或接口， *N* ：类或接口 *C* 的标记（类或接口二进制名称），*L* ：用户自定义类加载器）

​     Java虚拟机启动是通过启动类加载器创建一个初始类来完成的，该类加载器是虚拟机使用c++具体实现的。接着，虚拟机连接这个初始类，初始化并调用它的静态 main 方法。之后的整个执行过程都是对此方法的调用开始的。在执行main方法中的虚拟机指令可能会导致虚拟机连接（并于其后创建）另外的一些类或接口，也可能会令虚拟机调用另外的方法。

​	如果要创建标记为 *N* 的类或接口 *C*，需要现在虚拟机方法区上为 *C* 创建与虚拟机实现相匹配的内部表示。*C* 的创建是由另一个类或接口 *D* 所出发的，它通过自己的运行时常量池引用了 *C*。*C* 的创建也可能由 *D* 调用 JavaSE平台类库中的某些方法而出发，如反射等。

​	在虚拟机运行时，类或接口是由键值对的形式确定：二进制名称和它的定义加载器共同确定的。有时使用 < *N*，*L* > 来表示一个类或接口。

​	如果类加载器直接创建某个类或接口，这个类加载器被称为该类或接口的**定义加载器**。

​	如果类加载器把加载请求委托给其他的类加载器，这个类加载器被成为该类或接口的**初始加载器**。

​	**Java虚拟机通过下面三个过程之一来创建标记为 *N* 的类或接口 *C* ：**

- 如果 *N* 表示一个非数组的类或接口，那么可以用以下两种方式来加载并创建 *C* ：
  - 如果 *D* 是由启动类加载器所定义的，那么用启动类加载器来初始加载 *C* 。
  - 如果 *D* 是由用户自定义加载器所定义的，那么用该自定义加载器来初始加载 *C* 。
- 如果 *N* 表示一个数组类，那么该数组类是由虚拟机而不是类加载器创建。然而，在创建数组类 *C* 的过程中，也会用到 *D* 的定义类加载器。

#### 使用引导类加载器来加载类型

​	首先，虚拟机检查引导类加载器是否已标注成用 *N* 来表示的非数组类或接口的初始加载器。

​	如是，那么这个类或接口就是 *C* ，并且无需再创建类了。

​	如果不是，虚拟机将参数 *N* 传递给引导类加载器的特定方法，以平台相关的方式搜索 *C* 的描述（全限定名的方式搜索 **.*class*** 文件）。如果在搜索过程中未找到该描述或该描述不是对 *C* 的描述，则抛出 ClassNotFoundException的实例。

​	之后则根据 ***从class文件表示得到类*** 小节的算法，尝试通过引导类加载器来加载标识为 *N* 的描述，加载完成的类就是 *C* 。

#### 使用用户自定义类加载器来加载类型

​	首先，虚拟机检查自定义类加载器 *L* 是否已经标注为 *N* 所表示的类或接口的初始加载器。

​	如是，那么这个类或接口就是 *C* ，不再创建。

​	否则，虚拟机会调用 *L* 的 loadClass( *N* ) 方法。这次调用的返回值就是创建好的类或接口 *C* 。虚拟机会记录下 *L* 是 *C* 的初始加载器（见 ***加载限制*** 小节）。

​	当通过 *C* 的名称 *N* 去调用 *L* 的 loadClass 方法时，*L* 必须执行下面两种操作之一来加载 *C* ：

1. 类加载器 *L* 可以通过创建一个如 ClassFile 结构（见 Java虚拟机规范4.1节）的字节数组来表示 *C* ；然后必须调用 ClassLoader 的 defineClass 方法。调用 defineClass 方法会让虚拟机使用 ***从class文件表示得到类***  小节的算法通过 *L* 由字节数组得到标记为 *N* 的类或接口 *C* 。
2. 类加载器 *L* 可能把对 *C* 的加载请求委托给其他类加载器 *L‘* 。这是通过直接或简介传递参数 *N* 来调用 *L’* 的方法（一般是loadClass方法）而完成的。这次调用会产生 *C*。

无论何种方式，只要类加载器由于任何原因不能加载标识为 *N* 的类或接口，那么它就必须抛出 ClassNotFoundException 异常。

#### 创建数组类

​	使用类加载器 *L* 来创建标记为 *N* 的数组类 *C* 的过程如下所示，其中类加载器 *L* 可以是引导类加载器或用户自定义类加载器。

​	如果 *L* 已经被虚拟机记录成某个与 *N* 有相同元素类型的数组类的初始加载器，那么类就是 *C* ，不再创建新的数组类。（即已经加载过该数组类）

​	否则创建 *C* 的过程遵循以下步骤：

1. 如果组件类型是引用类型，那就在类加载器 *L* 上面递归运用本节算法，以加载和创建 *C* 的组件类型。
2. 虚拟机使用指定的组件类型（基础数据类型）和数组维度来创建新的数组类型，把数组类 *C* 标记为被引导类加载器定义过。

​	如果组件类型是引用类型，那就把 *C* 标记为它已经被该组件类型的定义类加载器定义过。否则，就把 *C* 标记为它被引导类加载器定义过。

​	不管哪种情况，虚拟机都会把 *L* 记录为 *C* 的初始加载器。

​	如果数组的组件类型是引用类型，那么数组类的可访问性就有组件类型的可访问性决定，否则可访问性默认为public。

***自我思考：*** 

​	数组是由虚拟机直接创建而不是类加载器，这里的创建数组类指得是创建数组元素的类型。

​	组件类型是数组类型最外面那一维元素的类型。一个数组的组件类型也可以是数组，此时就取这个小数组的组件类型，直到组件类型不是数组类型，就把这种类型成为本数组类型的元素类型。

#### 加载限制

​	类加载器需要特别考虑类型的安全链接问题。一种可以能出现的情况是，当两个不同的类加载器初始加载相同标记为 *N* 的类或接口时，每个加载器中的 *N* 表示的不是同一个类或接口（类或接口由二进制名称和加载器共同确定）。

​	当类或接口 *C* = <N1,L1> 含有指向另一个类或接口 *D* = <N2,L2> 的字段或方法的符号引用时，这个符号引用会包含表示字段类型，或方法参数和返回值类型的描述符。重要的是：字段或方法描述符里提到的任意类型名称 *N* ,无论是由 L1 加载还是 L2 加载，其结果都应该表示同一个类或接口（见 ***自定义类加载器实现*** 小节中的注意事项）。

​	为了确保这一原则，虚拟机在***准备*** 和***解析*** 阶段会强制实施 “<N,L1>=<N,L2>” 形式的**加载约束**。为了强制实施这个约束，虚拟机会在某些关键点（**创建和加载**阶段）把特定的加载器记录为特定类的初始加载器。在记录下一个加载器是某个类的初始加载器后，虚拟机会立即检查是否违反了这一约束。如果发生违约情况，将撤销这次记录，虚拟机会抛出 LinkageError，而导致记录产生的那次加载操作也同样失效。

​	与之相似的，在强制执行加载约束（**准备和解析**阶段）之后，虚拟机也必须立即检查是否有违约情况发生。如果有，那么最新的那个加载约束就会被撤销，虚拟机会抛出 LinkageError 异常，引入约束（可能在解析或准备阶段，视情况而定）的那些操作也会失败。

​	本小节所描述的这个时机，就是虚拟机能够检查加载约束是否遭到违反的唯一时机。当且仅当以下四个条件满足时，才算违反了加载约束：

- 类加载器 *L* 被虚拟机记录为由 *N* 所表示的类 *C* 的初始加载器；
- 类加载器 *L’* 被虚拟机记录为由 *N* 所表示的类 *C‘* 的初始加载器；
- 由施加的约束集（或者说，约束集的传递闭包）所定义的等价关系，意味着 <N,L>=<N,L’> 。
- C ≠ C‘ 。

以上条件简而言之就是：两个不同的类加载器作为相同标记为 *N* 的类或接口的初始加载器，在准备和解析阶段被施加加载约束，但类或接口 *C* 不等于 *C’* 。

#### 从class文件表示得到类

​	以下步骤是描述类加载器 *L* 从 ***.class*** 文件的描述中得到标记为 *N* 的非数组类或接口 *C* 的 Class 对象。

1. 首先，虚拟机检查 *L* 是否已经被记录为由 *N* 所表示的类或接口的初始加载器。如果是，那么这次创建的尝试动作是无效的，且加载动作抛出LinkageError异常。

2. 如果不是，虚拟机尝试解析二进制表示。但是，这个二进制表示可能不是 *C* 的有效描述。这个阶段的加载动作必须能够检测出下列错误：

   - 如果发现这个正在加载的描述不符合 ***ClassFile*** 结构（见 Java虚拟机规范 4.1节和4.8节），那么加载过程将抛出ClassFormatError异常。
   - 符合 ***ClassFile*** 结构的话，如果这份二进制表示里的主版本号或副版本号不受虚拟机支持，那么加载动作就会抛出UnspportedClassVersionError异常。

   ```
   UnspportedClassVersionError异常是ClassFormatError的子类，可以轻易地从ClassFormatError异常中区分那些在尝试加载某个类时，因该类的数据所使用的Class文件格式版本不受支持而引发的错误。
   ```

   - 版本号受虚拟机支持的话，如果该描述不能真正表示名称为 *N* 的类，那么加载过程就会抛出NoClassDefError异常或其子类的异常。

3. 如果 *C* 有一个直接父类，那么由 *C* 到直接父类的符号引用就需要 ***类与接口解析（位于链接的解析节中）*** 小节描述的算法来解析。需要注意的是，如果 *C* 是一个接口，那它必须以Object作为直接父类，而Object必定已经被加载过。只有Object类才没有自己的直接父类。

   ​	类或接口解析过程中的异常可以被当做这一加载阶段中的异常而抛出。除此之外，加载阶段还必须可以检查以下错误：

   - 如果类或接口 *C* 的直接父类事实上是一个接口，那么加载过程就必须抛出 IncompatibleClassChangeError异常（不兼容）。
   - 否则，如果 *C* 的父类是 *C* 自己，那么加载过程就必须抛出ClassCircularityError异常（循环）。

4. 如果 *C* 有一写直接父接口，那么由 *C* 到它的直接父接口的符号引用就需要使用 ***类与接口解析（位于解析节中）*** 小节描述的算法来解析。

   ​		类或接口解析过程中的异常可以被当做这一加载阶段中的异常而抛出。除此之外，加载阶段还必须可以检查以下错误：

   - 如果类或接口 *C* 的直接父接口事实上不是一个接口，那么加载过程就必须抛出 IncompatibleClassChangeError异常（不兼容）。
   - 否则，如果 *C* 的某个父接口是 *C* 自己，那么加载过程就必须抛出ClassCircularityError异常（循环）。

5. 虚拟机标记 *C* 的定义类加载器是 *L* ，并且记录下 *L* 是 *C* 的初始加载器。

### 链接

​	链接类或接口包括验证和准备类或接口、它的直接父类、它的直接父接口、它的元素类型（如果是一个数组类型）。而解析这个类或接口的引用符号则是链接过程中的可选部分（解析与初始化交换顺序实现动态绑定）。

​	虚拟机规范允许灵活地选择链接（及由于递归链接而引发的加载）时机，但必须保证下列几点成立：

- 在类或接口被连接之前，它必须被成功地加载过。

- 在类或接口初始化之前，它必须被成功地验证及准备过。

- 若程序执行了某种可能需要直接或简介链接一个类或接口的动作，而在链接该类或接口的过程中又检测到了错误，则错误的抛出点应是执行动作的那个点。

  ​	例如，虚拟机实现可以在用到类或接口的符号引用时才去逐一解析它（延迟解析），或者在验证类的时候就解析每个引用（预先解析）。这意味着在一些虚拟机实现中，当类或接口初始化之后，解析动作可能还在进行。不管采用哪种策略，解析过程中的任何错误都必须抛出，抛出的位置是在通过直接或间接使用符号引用而导致解析过程发生的程序处。

  ​	由于链接过程会涉及新数据结构的内存分配，因此它可能因为发生OutOfMemoryError异常而导致失败。

  ***自我思考*** ：链接时机主要体现在延迟解析和预先解析，延迟解析即交换解析和初始化的顺序实现动态绑定。

#### 验证

​	验证（见Java虚拟机规范中 4.10小节class文件校验）阶段用于确保类或接口的二进制表示在结构上是正确的（见4.9节 代码约束）。验证过程可能会导致某些额外的类或接口被加载进来，但不一定会导致它们也需要验证或准备。

​	如果类或接口的二进制表示不能满足 4.9节（代码约束） 中描述的静态或结构上的约束，那就必须在导致验证发生的程序出抛出 VerifyError异常。

​	如果 Java 虚拟机尝试验证类或接口，却因为抛出了 LinkageError或其子类的实例而导致验证失败，那么随后对于此类或接口的验证尝试，就总是会由于与第一次尝试失败相同的原因而失败。（类加载器 *L* 已被记录为由 *N* 所表示的类或接口 *C* 的初始加载器，在加载时则会抛出 LinkageError） 

#### 准备

​	准备阶段的任务是创建类或接口的静态字段，并用默认值初始化这些字段。这个阶段不会执行任何的虚拟机字节码指令。在初始化阶段会有显式的初始化器来初始化这些静态字段，所以准备阶段不做这些事情。

​	在某个类或接口 *C* 的准备阶段，虚拟机也会有强制实施加载约束。假定 *L1* 是 *C* 的定义加载器。对于每个声明在 *C* 中的方法 *m* 来说，如果它覆盖了声明在 *C* 的父类或父接口 <D,L2>中的某个方法，那么虚拟机强制执行下面的加载约束：

```
	给定的 *m* 的返回值类型是 *Tr* ，并且给定 *m* 的形参类型从 *Tf1*，.....，*Tfn*，则如果 *Tr* 不是数组类型，那么用 *To* 代替 *Tr* ；不然的话 *To* 就表示 *Tr* 的元素类型。

	对于从1到n的每个 i 来说，如果 *Tfi* 不是数组类型，那么 *Ti* 表示 *Tfi* ；不然， *Ti* 就是 *Tfi* 的元素类型。

	对于从0到n的每个 i 来说，<Ti，L1> = <Ti，L2 >都应该成立（即方法的返回值类型和参数类型的加载被实施加载约束）。
```

​	此外，如果 *C* 实现了它的父接口< I，L3 >中的方法 *m* ，但 *C* 自己却没有声明这个方法 *m* ，那么就把声明了有 *C* 所继承的方法 *m* 实现的那个超类记为<D，L2>。虚拟机强制施加如下约束：

```
	给定的 *m* 的返回值类型是 *Tr* ，并且给定 *m* 的形参类型从 *Tf1*，.....，*Tfn*，如果 *Tr* 不是数组类型，那么用 *To* 代替 *Tr* ；不然的话 *To* 就表示 *Tr* 的元素类型。

	对于从1到n的每个 i 来说，如果 *Tfi* 不是数组类型，那么 *Ti* 表示 *Tfi* ；不然， *Ti* 就是 *Tfi* 的元素类型。

	对于从0到n的每个 i 来说，<Ti，L2> = <Ti，L3 >都应该成立（即方法的返回值类型和参数类型的加载被实施加载约束）。
```

​	在创建好类之后的任何时间，都可以进行准备，但一定要保证在初始化阶段开始前完成。

#### 解析

​	虚拟机指令 ***anewarray*** 、***checkcast*** 、***getfiled*** 、***getstatic*** 、***instanceof*** 、***invokedynamic*** 、***invokeinterface*** 、***invokespecial*** 、***invokestatic*** 、***invokevirtual*** 、***ldc*** 、***ldc_w*** 、***multianewarray*** 、***new*** 、***putfield*** 和 ***putstatic*** 将符号引用指向运行时常量池。执行上述任何一条指令都需要对它的符号引用进行解析。

​	**解析是根据运行时常量池的符号引用来动态决定具体值的过程。**

​	当碰到一次 ***invokedynamic*** 指令而去解析它的符号引用后，并不意味着对于其他 ***invokedynamic*** 指令来说，相同的符号引用也被解析过（即每个 ***invokedynamic*** 独立解析它的符号引用）。

​	但是对于上述其他指令来说，当碰到这个指令并解析它的符号引用后，就表示对于其他的非 ***invokedynamic*** 指令来说，相同的符号引用已经被解析过了。

​	（上面内容暗示：由特定的 ***invokedynamic*** 指令的解析结果所决定的那个具体值，是一个绑定到该 ***invokedynamic*** 指令的调用点对象）

​	解析过程也可以尝试去重新解析之前成功解析过的符号引用。这样的尝试动作总是像之前一样成功，并且总是返回与此引用初次解析的结果相同的实体。

​	如果在解析某个符号引用时发生错误，则应该在（直接或间接）使用该符号引用的程序处抛出 IncompatibleClassChangeError或它的子类异常。

​	如果在虚拟机解析符号引用时，因为LinkageError或它的子类实例而导致失败，那么随后解析此引用时，都会抛出与第一次解析时相同的错误。

​	对于由 ***invokedynamic*** 指令所指定的调用点限定符来说，指向该限定符的符号引用，在执行那个指令之前不能提前解析。

​	如果解析某个 ***invokedynamic*** 指令的时候出错，那么引导方法在随后尝试解析时就不再重新执行了。

​	上述某些指令在解析符号引用时，需要有额外的链接检查，例如 ***getfield*** 指令为了成功解析指向该指令所需要操作的那个字段的符号引用，不仅需要完成 ***字段解析*** 步骤，而且还需要检查该字段是不是static的。如果是static的，那就必须抛出链接时异常。

​	尤其注意的是：为了让 ***invokedynamic*** 指令成功解析某个调用点限定符的符号引用，指定的引导方法必须正常完成并返回一个合适的调用点对象。如果引导方法被打断或返回了一个不合适的调用点对象，那么也必须抛出链接时异常。

​	下面描述对于类或接口 *D* 的运行时常量池里的符号引用进行解析的过程。解析细节会因为符号引用种类的不同而有所不同。

##### 类与接口解析

​	虚拟机为了解析 *D* 中对标记为 *N* 的类或接口 *C* 的未解析符号引用，会执行如下步骤：

1. *D* 的定义类加载器被用来创建标记为 *N* 的类或接口。这个类或接口是 *C* 。（此过程即 ***创建和加载*** ）

    创建类或接口时所抛出的异常，可以当成因解析类或接口失败所导致的异常而抛出。

2. 如果 *C* 是数组类且它的元素类型是引用类型，那么指向表示元素类型的类或接口的符号引用会按照此算法来递归解析。

3. 最后，检查 *C* 的访问权限：

    ​	如果 *C* 对 *D* 是不可见的，那么类或接口的解析会抛出 IllegalAccessError。

    ``` 
    这种情况有可能发生，例如，C是一个原来声明为public的类，但它在D编译后被改成非public
    ```

    如果第1步和第2步成功但是第3步失败，那么 *C* 仍然是有效且可用的。但解析是失败的，而且 *D* 不能访问 *C* 。

##### 字段解析

​	如果要解析从 *D* 指向类或接口 *C* 中的某个字段的未解析符号引用，那么必须先解析指向该字段引用所提到的那个 *C* 的符号引用（见***类与接口解析***）。因此，在解析类或接口引用时发生的任何异常都可以当做解析字段引用的异常抛出。如果指向 *C* 的引用成功解析，那么可以抛出解析字段引用本身时发生的异常。

​	当解析字段引用时，字段解析过程会先尝试在 *C* 和它的父类查找这个字段：

1. 如果 *C* 中声明的某个字段，与字段引用有相同的名称及描述符，那么此次查找成功。字段查找的结果就是 *C* 中那个声明的字段。

2. 否则，字段查找过程会递归地应用到类或接口 *C* 的直接父接口上。

3. 否则，如果 *C* 有一个父类 *S* ，那么字段查找会递归应用到 *S* 上。

4. 如果还未找到，则字段查找失败。

    然后：

    - 如果字段查找失败，字段解析过程会抛出 NoSuchFieldError。
    - 否则，如果字段查找成功，但是引用的那个字段对 *D* 是不可见的，那么字段解析会抛出 IllgalAccessError异常。
    - 否则，假设<E,L1>是真正声明所引用字段的那个类或接口，*L2* 是 *D* 的定义加载器。给定引用字段的类型是 *Tr* ，那么当 *Tf* 是非数组类型时，*T=Tf*，而当 *Tf* 是数组时，*T* 是它的元素类型。虚拟机必须强制实施加载约束：<T，L1>=<T，L2>。

##### 普通方法解析

​	

#### 访问控制





#### 方法覆盖

## ClassLoader源码分析

### defineClass方法

​	将字节码数组转换成类类型的实例，该类型在使用前必须要对其进行链接。

​	此方法将一个默认ProtectionDomain分配给新定义的类。ProtectionDomain被有效地授予与Policy.getPolicy().getPermissions(new CodeSource(null, null)) 被调用时返回的权限集相同的权限。默认域是在第一次调用defineClass时创建的，并在后续调用中重用。

​	要将特定的ProtectionDomain分配给类，请使用将ProtectionDomain作为其参数之一的defineClass方法。

```java
    protected final Class<?> defineClass(String name, byte[] b, int off, int len)
        throws ClassFormatError
    {
        return defineClass(name, b, off, len, null);
    }
```



# 运行时数据区

 [![img](https://camo.githubusercontent.com/397eed8a3eff96cc19cedbee1f20f100afaf6295/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67)](https://camo.githubusercontent.com/397eed8a3eff96cc19cedbee1f20f100afaf6295/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67) 



 [![img](https://camo.githubusercontent.com/397eed8a3eff96cc19cedbee1f20f100afaf6295/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67)](https://camo.githubusercontent.com/397eed8a3eff96cc19cedbee1f20f100afaf6295/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67) 



## 程序计数器

​	程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里 [1] ，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

​	由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯
一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

​	 “概念模型”这个词会经常被提及，它代表了所有虚拟机的统一外观，但各款具体的Java虚拟机并不一定要完全照着概念模型的定义来进行设计，可能会通过一些更高效率的等价方式去实现它。

## Java 虚拟机栈

​	每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

​	**局部变量表存放了编译期可知**的各种 Java 虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和**returnAddress类型**（指向了一条字节码指令的地址）。

​	这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，**其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。**请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。

 [![img](https://camo.githubusercontent.com/96d3e63fbdedc3e6af5f8365815898bef9799ea3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38343432353139662d306234642d343866342d383232392d3536663938343336336336392e706e67)](https://camo.githubusercontent.com/96d3e63fbdedc3e6af5f8365815898bef9799ea3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38343432353139662d306234642d343866342d383232392d3536663938343336336336392e706e67) 



可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：

```
java -Xss2M HackTheJava
```

该区域可能抛出以下异常：

- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

​	**HotSpot虚拟机的栈容量是不可以动态扩展的。**所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的。

## 本地方法栈

本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

 [![img](https://camo.githubusercontent.com/1d8a26c9cee39aa0d6f7e1a165b422f0fa0d4187/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36366136383939642d633662302d346134372d383536392d3964303866306261663836632e706e67)](https://camo.githubusercontent.com/1d8a26c9cee39aa0d6f7e1a165b422f0fa0d4187/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36366136383939642d633662302d346134372d383536392d3964303866306261663836632e706e67) 





## 堆

所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：

- 新生代（Young Generation）
- 老年代（Old Generation）

​	分代的区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个 Java虚拟机具体实现的固有内存布局，更不是《虚拟机规范》里对 Java堆的进一步细致划分。

​	堆不需要连续内存，但在逻辑上它应该被视为连续的。堆可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

```shell
java -Xms1M -Xmx2M HackTheJava
```



## 方法区

​	用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。

​	**对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。**

​	HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC  之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8  开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

​	方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。**元空间存储类的元信息（类型信息）**，**而静态变量和常量池等放入堆中。**



## 运行时常量池

​	运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

​	除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。



## 直接内存

​	直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分的内存也被频繁使用。

​	在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存（Java堆）和堆外内存（Native堆）来回拷贝数据。

​	显然，本机直接内存的分配不会受到 Java堆大小的限制。但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。

## HotSpot对象虚拟机探秘

***本章节来自深入理解Java虚拟机：JVM高级特性与最佳实践（第 3版）的 2.3节***

### 对象的创建

​	当 Java虚拟机遇到一条**字节码new指令 **时，首先将去检查这个**指令的参数是否能在常量池中定位到**一个**类的符号引用**，并且检查这个**符号引用代表的类是否已被加载、解析和初始化过**。如果没有，那必须先执行相应的[类加载过程](#类的加载过程)。

​	在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定见[对象的内存布局](#对象的内存布局)），为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。

**1.创建对象时的内存分配：**

​	假设 **Java堆中内存是绝对规整的**，所有**被使用过的内存都被放在一边**，**空闲的内存被放在另一边**，**中间放着一个指针作为分界点的指示器**，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“**指针碰撞”（Bump ThePointer）**。

​	但如果 **Java堆中的内存并不是规整的**，**已被使用的内存和空闲的内存相互交错在一起**，那就没有办法简单地进行指针碰撞了，虚拟机就必须**维护一个列表**，记录上哪些内存块是可用的，在**分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录**，这种分配方式称为**“空闲列表”（Free List）**。

​	选择哪种分配方式由Java堆是否规整决定，而 Java堆是否规整又由所采用的**垃圾收集器是否带有空间压缩整理（Compact）的能力决定**。因此，当使用**Serial、ParNew等带压缩整理过程的收集器**时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用**CMS这种基于清除（Sweep）算法的收集器**时，理论上就只能采用较为复杂的空闲列表来分配内存。（强调“理论上”是因为在CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作LinearAllocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指针碰撞方式来分配。）

​	对象分配还需要考虑另外一个问题：并发情况下的对象创建。解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用 **CAS** 配上 **失败重试** 的方式保证更新操作的原子性；另外一种是把内存分配按照线程划分在不同的空间中进行的，即每个线程在 Java堆中预先分配一小块内存，成为**本地线程分配缓冲**（Thread Local Allocation Buffer, TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区分配，**只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定**。虚拟机是否使用TLAB，可以通过 **-XX: +/-UseTLAB** 参数来设定。

**2.分配内存后的工作：**

​	内存分配完后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了TLAB，那么在该工作分配TLAB时顺便进行了。这步操作保证了对象的实例字段在 Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

​	接下来，Java虚拟机还要对对象进行必要的设置，例如这个**对象是哪个类的实例**、如何才能找到类的元数据信息、**对象的哈希码**（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。**这些信息存放在对象的对象头（Object Header）之中。**根据虚拟机当前**运行状态的不同**，如是否启用偏向锁等，**对象头会有不同的设置方式**。

​	此时，从虚拟机的角度上来看，对象的创建已经完成。但是从 Java程序角度来看，对象创建才刚刚开始——构造函数，即 Class文件中的 **\<init>()** 方法还没有执行，所有字段的值都默认为零，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说[^注1]，new指令之后会接着执行**\<init>()** 方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

​	在《深入理解Java虚拟机：JVM高级特性与最佳实践（第三版）》中，有HotSpot虚拟机字节码解释器（bytecodeInterpreter.cpp）中的代码片段。这个解释器实现很少有机会实际使用，大部分平台上都使用模板解释器；当代码通过即时编译器执行时差异就更大了。不过这段代码用于了解HotSpot的运作过程是没有什么问题的。（这里不贴出代码，如需请自行查找书籍）

#### 自我理解

**虚拟机中对象创建的逻辑：**

1.对象的创建必然需要占用堆内存，虚拟机就需要为对象分配内存空间；

2.虚拟机为对象分配内存空间需要根据空闲内存的规整程度（即空闲与非空闲的内存是否完全按逻辑分开）决定使用哪种分配策略（是否规整由所采用垃圾收集器是否带有空间压缩整理（Compact）的能力决定）；

3.空闲内存绝对规整使用**“指针碰撞”（空闲内存与非空闲内存的分界器）**，反之使用**“空间列表”（记录哪些内存空间可用）**；

4.考虑并发的问题，有两种策略：一是使用 CAS 配上失败重试的方式保证操作原子性；二是通过为每个线程分配本地线程缓冲（TLAB，每个线程在堆中有自己的空间，不够再同步扩容）；

5.对象内存分配完成后需要将内存空间的值初始化为零，之后需要对对象进行比较配置，如对象头信息等。此时从虚拟机角度上对象已经创建完毕，但并未调用构造函数（\<init>() 方法并执行）。

[^注1]: 执行 \<init>() 方法由字节码流中new指令后面是否跟随 invokespecial 指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此

### 对象的内存布局

​	在HotSpot虚拟机里，对象在堆中的内存布局被分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

**1.对象头（Header）：**

​	HotSpot虚拟机对象的对象头包含两类信息。

​	第一类信息是**Mark Word**，用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特。

​	对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，**Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。**例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示：

| 存储内容                             | 标志位 | 状态                     |
| :----------------------------------- | :----- | :----------------------- |
| 对象哈希码、对象分代年龄             | 01     | 未锁定（上面例子的状态） |
| 指向锁记录的指针                     | 00     | 轻量级锁定               |
| 指向重量级锁的指针                   | 10     | 膨胀（重量级锁定）       |
| 空，不需要记录信息                   | 11     | GC标记                   |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向                   |

***注意：标志位为 01时，有两个状态，对象具体处于哪个状态由存储内容决定。***

​	第二类信息是**类型指针**，即对象指向它的类型元数据的指针，虚拟机通过该指针确定对象属于哪个类的实例。也有些虚拟机实现没有在对象数据上保留类型指针，而是通过其它方式查找对象的元数据信息。此外，如果对象是一个 Java数组，那么在对象头中还必须存在一块用于记录数组长度的数据（这也是为什么 Java一些集合类的最大容量是 MAX_ARRAY_SIZE），因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。

**2.示例数据（Instance Data）：**

​	该部分是**对象真正存储的有效信息**，即在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会收到虚拟机**分配策略参数（-XX: FieldsAllocationStyle）**和字段在 Java源码定义顺序的影响。

​	HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，**相同宽度的字段总是被分配到一起存放**，在**满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前**。如果HotSpot虚拟机的**+XX：CompactFields**参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。

**3.对齐填充（Padding）：**

​	对象的第三部分是**对齐填充**，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是**任何对象的大小都必须是8字节的整数倍**。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

### 对象的访问定位

​	Java程序代码在使用对象时，会通过虚拟机栈上的**reference数据**来操作堆上的具体对象。在《Java虚拟机规范》中并没有定义reference类型通过什么方式访问对象的具体位置，只是规定它是一个指向对象的引用。因此，对象的访问方式由虚拟机实现而定，主流的访问方式有使用**句柄**和**直接指针**。

​	如果使用**句柄访问**的话，Java堆中可能会划分出一块内存作为句柄池，**reference中存储的就是对象的句柄地址**，而**句柄中包含了对象到实例数据和类型数据的指针**，结构如下图所示：

![reference通过句柄访问对象数据](C:\Users\Administrator\Desktop\学习\java\reference通过句柄访问对象数据.png)

​	如果使用**直接指针**访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，**reference中直接存储对象地址**。如果只是访问对象本身的话，就不需要多一次间接访问的开销，其结构如下图所示。

![reference通过直接指针访问对象数据](C:\Users\Administrator\Desktop\学习\java\reference通过直接指针访问对象数据.png)

​	这两种对象访问方式各有优势：

- **使用句柄来访问**：最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的指向实例数据的指针，而reference本身不需要被修改。
- **使用直接指针来访问**：最大好处就是速度快，因为它节省了一次指针定位的开销，由于对象访问在 Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它主要使用第二种方式进行对象访问（有例外情况，如果使用了Shenandoah收集器的话也会有一次额外的转发，具体可参见[垃圾收集器与内存分配策略](#垃圾收集器与内存分配策略)），但从整个软件开发的范围来看，在各种语言、框架中使用句柄来访问的情况也十分常见。





# 垃圾收集器与内存分配策略



# 执行引擎



# 本地方法接口（JNI）



# 参考资料

[Java Class Loaders Explained](https://javatutorial.net/java-class-loaders-explained)

[CyC2018/CS-Notes/java 虚拟机](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md)

 **深入理解Java虚拟机：JVM高级特性与最佳实践（第3版） (华章原创精品) - 周志明**