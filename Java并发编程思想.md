











# Java并发编程思想

# 线程安全性

​	对于线程安全的定义越正式就越复杂，复杂的定义就会导致参考价值降低。因此对于线程安全的定义不必过于深究，只需了解安全性相似概念即可。

​	安全性并非指数据不可被窃取的安全。要了解安全性首先需要了解正确性，**正确性的含义是指某个类的行为与其规范完全一致**。安全性的定义就可在正确性的基础上建立：**当多个线程访问某个类时，这个类始终都能变现出正确的行为，那么就称这个类是线程安全的。**

​	有了上面的认知，我们可以知道安全性与正确性相关，正确性与行为和规范有关。一个良好的规范通常会定义各种**不变性条件**（`final`关键字，常量等）约束对象的状态，以及定义各种**后检条件**（期望值等）来描述对象操作的结果。

​	只使用**不可变类**的线程也能保证线程安全，相当于只使用常量。不存在状态的改变，也就不存在安全性的问题。

> 无状态对象一定是线程安全的。

​	个人理解：对于线程安全问题来说，主要是解决可变状态的一致性问题，只要状态在多个线程中被修改后保持一致，那么线程安全的问题就不是问题了。后面介绍的线程安全实现方式都是通过某种方式使得状态对多个线程表现出一致性，例同步机制（独占状态）、缩小状态影响范围（TreadLocal）等。

下面介绍几种保证线程安全的实现方式：

## 原子性

​	原子性是指一个或一组操作要么全部成功，要么全部失败。原子性操作具有不可分割的特性，如果将原子操作分成几个小操作，那么这几个小操作并不是一定具备原子性。同样地，两个原子操作组成一个操作也不一定具有原子性，需要添加一些控制信息使其编程原子操作。

​	不具有原子性的操作，就意味着操作可以在任何时间处于任何状态，这种不确定性也就导致不正确的结果。

### 竞态条件

​	在并发编程中，由于不恰当的执行时序而出现不正确的结果的程序段，就称存在**竞态条件**。导致竞态条件发生的代码称作**临界区**。

​	最常见的竞态条件类型就是**“先检查后执行（check-then-act）”操作**，即通过一个可能失效的观测结果来决定下一步动作。例如，通过观测某个条件为真（文件X不存在），然后根据这个观察结果采用相应动作（创建文件X），但其实可能在观测出结果与做出动作之间的时间端，其他线程创建了文件X，这种操作会导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。最典型的例子就是单例模式中的“懒汉式”实现。

​	另一种竞态条件类型是“读取-修改-写入”操作，例如递增运算。从JMM的角度看递增运算，就会发现其在并发环境下会存在竞态条件的问题。

​	要避免竞态条件，就必须在某个线程修改变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作之前或之后读取和修改状态，而不是在修改状态的过程中。例如给操作增加原子性（如原子类）、加锁等。

## 加锁机制

​	Java提供了一种内置的锁机制来支持原子性：**同步代码块（Synchronized Block）**。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字`Synchronized`来修饰的方法就是一种横跨整个方法体的同步代码块[^注1.2.1]，其中该同步代码块的锁就是方法调用所在的对象。静态的`Synchronized`方法以 `Class`对象作为锁。

​	每个Java对象都可以用作实现同步的锁，在对象头中的`Mark Word`设置锁标志，使得对象成为一种**互斥体**，意味着最多只有一个线程能持有。在并发环境下，只有一个线程执行意味着其他线程必须等待，也就导致性能降低。

​	同步代码块通过锁的保护，使得整个同步代码块具有原子性，成为一组不可分割的执行单元。

​	一个锁应当具备可重入性，可重入性是指某个线程试图获得一个已经由它自己持有的锁时必定成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”[^注1.2.2]。重入的实现方式是通过一个计数器记录获取该锁的次数，计数器值为0时，锁就被释放。

​	如果锁不具备重入性，线程将可能发生死锁的情况，如下代码就会产生死锁（假设锁不具备重入性）：

```java
public class Widger{
    public synchronized void doSomething() {
        ...
    }
    
    public class LoggingWidget extands Widget {
        public synchronized void doSomething() {
            super.doSomething();
        }
    }
}
```

> **使用锁保护状态：**
>
> ​	在并发编程中，对于能够修改同一状态（例如一个或多个变量的组合）的行为都应该使用同一个锁进行加锁，否则还是会存在竞态条件的问题而出现不正确的结果。

[^注1.2.1]:同步方法和同步代码块实现不同，前者是设置标志位，后者是通过添加字节码。
[^注1.2.2]:这与pthread（POSIX线程）互斥体的默认加锁行为不同，pthread互斥体的获取操作是以“调用”为粒度的。

## 性能考虑

​	在并发编程过程中，使用`synchronized`关键字应当考虑到并发性能的问题，不能一昧地追求线程安全。所以在设计一个同步方法或同步类时，应将共享代码段与非共享代码段区分开，方便开发人员对哪些代码段进行同步。

​	在使用加锁机制时，应当根据代码块的功能以及执行该代码块所需时间来判断是否应该加锁。例如过长时间持有锁就会导致系统性能降低的问题。

​	总的来说，使用加锁机制时应注意同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性、简单性和性能（并发性）。

# 对象的共享



# 参考资料

《Java Concurrency in Practiee》（中文名：《Java并发编程实战》） —— Brian Goetz 等著