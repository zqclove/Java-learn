[TOC]

# Java并发编程思想

# 线程安全性

​	对于线程安全的定义越正式就越复杂，复杂的定义就会导致参考价值降低。因此对于线程安全的定义不必过于深究，只需了解安全性相似概念即可。

​	安全性并非指数据不可被窃取的安全。要了解安全性首先需要了解正确性，**正确性的含义是指某个类的行为与其规范完全一致**。安全性的定义就可在正确性的基础上建立：**当多个线程访问某个类时，这个类始终都能变现出正确的行为，那么就称这个类是线程安全的。**

​	有了上面的认知，我们可以知道安全性与正确性相关，正确性与行为和规范有关。一个良好的规范通常会定义各种**不变性条件**（`final`关键字，常量等）约束对象的状态，以及定义各种**后检条件**（期望值等）来描述对象操作的结果。

​	只使用**不可变类**的线程也能保证线程安全，相当于只使用常量。不存在状态的改变，也就不存在安全性的问题。

> 无状态对象一定是线程安全的。

​	个人理解：对于线程安全问题来说，主要是解决可变状态的一致性问题，只要状态在多个线程中被修改后保持一致，那么线程安全的问题就不是问题了。后面介绍的线程安全实现方式都是通过某种方式使得状态对多个线程表现出一致性，例同步机制（独占状态）、缩小状态影响范围（TreadLocal）等。

下面介绍几种保证线程安全的实现方式：

## 原子性

​	原子性是指一个或一组操作要么全部成功，要么全部失败。原子性操作具有不可分割的特性，如果将原子操作分成几个小操作，那么这几个小操作并不是一定具备原子性。同样地，两个原子操作组成一个操作也不一定具有原子性，需要添加一些控制信息使其编程原子操作。

​	不具有原子性的操作，就意味着操作可以在任何时间处于任何状态，这种不确定性也就导致不正确的结果。

### 竞态条件

​	在并发编程中，由于不恰当的执行时序而出现不正确的结果的程序段，就称存在**竞态条件**。导致竞态条件发生的代码称作**临界区**。

​	最常见的竞态条件类型就是**“先检查后执行（check-then-act）”操作**，即通过一个可能失效的观测结果来决定下一步动作。例如，通过观测某个条件为真（文件X不存在），然后根据这个观察结果采用相应动作（创建文件X），但其实可能在观测出结果与做出动作之间的时间端，其他线程创建了文件X，这种操作会导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。最典型的例子就是单例模式中的“懒汉式”实现。

​	另一种竞态条件类型是“读取-修改-写入”操作，例如递增运算。从JMM的角度看递增运算，就会发现其在并发环境下会存在竞态条件的问题。

​	要避免竞态条件，就必须在某个线程修改变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作之前或之后读取和修改状态，而不是在修改状态的过程中。例如给操作增加原子性（如原子类）、加锁等。

## 加锁机制

​	Java提供了一种内置的锁机制来支持原子性：**同步代码块（Synchronized Block）**。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字`Synchronized`来修饰的方法就是一种横跨整个方法体的同步代码块[^注1.2.1]，其中该同步代码块的锁就是方法调用所在的对象。静态的`Synchronized`方法以 `Class`对象作为锁。

​	每个Java对象都可以用作实现同步的锁，在对象头中的`Mark Word`设置锁标志，使得对象成为一种**互斥体**，意味着最多只有一个线程能持有。在并发环境下，只有一个线程执行意味着其他线程必须等待，也就导致性能降低。

​	同步代码块通过锁的保护，使得整个同步代码块具有原子性，成为一组不可分割的执行单元。

​	一个锁应当具备可重入性，可重入性是指某个线程试图获得一个已经由它自己持有的锁时必定成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”[^注1.2.2]。重入的实现方式是通过一个计数器记录获取该锁的次数，计数器值为0时，锁就被释放。

​	如果锁不具备重入性，线程将可能发生死锁的情况，如下代码就会产生死锁（假设锁不具备重入性）：

```java
public class Widger{
    public synchronized void doSomething() {
        ...
    }
    
    public class LoggingWidget extands Widget {
        public synchronized void doSomething() {
            super.doSomething();
        }
    }
}
```

> **使用锁保护状态：**
>
> ​	在并发编程中，对于能够修改同一状态（例如一个或多个变量的组合）的行为都应该使用同一个锁进行加锁，否则还是会存在竞态条件的问题而出现不正确的结果。

[^注1.2.1]:同步方法和同步代码块实现不同，前者是设置标志位，后者是通过添加字节码。
[^注1.2.2]:这与pthread（POSIX线程）互斥体的默认加锁行为不同，pthread互斥体的获取操作是以“调用”为粒度的。

## 性能考虑

​	在并发编程过程中，使用`synchronized`关键字应当考虑到并发性能的问题，不能一昧地追求线程安全。所以在设计一个同步方法或同步类时，应将共享代码段与非共享代码段区分开，方便开发人员对哪些代码段进行同步。

​	在使用加锁机制时，应当根据代码块的功能以及执行该代码块所需时间来判断是否应该加锁。例如过长时间持有锁就会导致系统性能降低的问题。

​	总的来说，使用加锁机制时应注意同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性、简单性和性能（并发性）。

# 对象的共享

​	在Java内存模型中，对于一个变量（泛指可以修改的数据）的读取和写入是通过6个原子操作[^注2.1]进行的。并且每个线程都有自己的**工作内存（用于存放变量副本）**，即线程与**主内存（变量真正存放的区域）**还存在一个类似缓冲区的区域。

​	当线程A对一个共享变量进行修改后，可能不会立即将修改后的值同步到主内存中，所以该变量在同一时间点上，在工作内存的值和在主内存的值就会存在不一致的情况。此时如果线程B读取该变量，它是“看不见”线程A所做的修改操作的。

[^注2.1]:6个原子操作为：read、load、use、assign、store、write，具体作用请自行搜索

## 可见性

​	**可见性**是指一个线程对变量的修改动作是能够被其他线程知道的。一个动作具有可见性，也就不会出现**失效数据**[^注2.1.1]的问题。

​	实现可见性最简单的方法就是对共享的变量进行**加锁**。当对一个变量的访问是互斥同步时，对该变量的修改就会同步写入主内存中，也就不会有不可见的问题发生。

​	Java还提供了一种稍弱的同步机制，即 `volatile` 变量，用来确保将变量的修改操作通知到其他线程。`volatile`关键字能实现可见性的关键在于**某线程对变量进行修改操作后，必须紧接着写入主内存。同样，对变量进行读取操作，也必须从主内存中读取**。但`volatile`不会阻塞线程，是一种较弱的同步机制，不应过度依赖它所提供的可见性。还有一点值得注意，`volatile`不提供原子性，对于 **count++** 递增操作是无法保证正确性的。

[^注2.1.1]:失效数据是指读取到的数据是旧数据，对于需要最新数据的线程来说是无用且错误的

## 发布与逸出

​	**发布**一个对象是指，**使对象能够在当前作用于之外的代码中使用**。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。

​	**逸出**与发布类似，**逸出**是发布的贬义表达，指的是**当某个不应该发布的对象被发布的情况**。

​	发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。在发布对象时，如果要确保线程安全，则可能需要同步。

​	下面列出发布对象的例子：

```java
public static Set<Secret> knownSecrets; 

public void initialize() {
	knownSecrets = new HashSet<Secrete>(); 
    // 将对象的引用保存在一个公有的静态变量中。
    // 并且Secret对象也被间接发布，因为任何代码都可以遍历这个集合。
}
```

​	发布也存在传递性，当一个已经被发布的对象通过非私有的变量引用和方法调用到其他对象，那么这些对象也都会被发布。

# 参考资料

《Java Concurrency in Practiee》（中文名：《Java并发编程实战》） —— Brian Goetz 等著