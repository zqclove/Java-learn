[TOC]

# Java并发编程思想

# 线程安全性

​	对于线程安全的定义越正式就越复杂，复杂的定义就会导致参考价值降低。因此对于线程安全的定义不必过于深究，只需了解安全性相似概念即可。

​	安全性并非指数据不可被窃取的安全。要了解安全性首先需要了解正确性，**正确性的含义是指某个类的行为与其规范完全一致**。安全性的定义就可在正确性的基础上建立：**当多个线程访问某个类时，这个类始终都能变现出正确的行为，那么就称这个类是线程安全的。**

​	有了上面的认知，我们可以知道安全性与正确性相关，正确性与行为和规范有关。一个良好的规范通常会定义各种**不变性条件**（`final`关键字，常量等）约束对象的状态，以及定义各种**后检条件**（期望值等）来描述对象操作的结果。

​	只使用**不可变类**的线程也能保证线程安全，相当于只使用常量。不存在状态的改变，也就不存在安全性的问题。

> 无状态对象一定是线程安全的。

​	个人理解：对于线程安全问题来说，主要是解决可变状态的一致性问题，只要状态在多个线程中被修改后保持一致，那么线程安全的问题就不是问题了。后面介绍的线程安全实现方式都是通过某种方式使得状态对多个线程表现出一致性，例同步机制（独占状态）、缩小状态影响范围（TreadLocal）等。

下面介绍几种保证线程安全的实现方式：

## 原子性

​	原子性是指一个或一组操作要么全部成功，要么全部失败。原子性操作具有不可分割的特性，如果将原子操作分成几个小操作，那么这几个小操作并不是一定具备原子性。同样地，两个原子操作组成一个操作也不一定具有原子性，需要添加一些控制信息使其编程原子操作。

​	不具有原子性的操作，就意味着操作可以在任何时间处于任何状态，这种不确定性也就导致不正确的结果。

### 竞态条件

​	在并发编程中，由于不恰当的执行时序而出现不正确的结果的程序段，就称存在**竞态条件**。导致竞态条件发生的代码称作**临界区**。

​	最常见的竞态条件类型就是**“先检查后执行（check-then-act）”操作**，即通过一个可能失效的观测结果来决定下一步动作。例如，通过观测某个条件为真（文件X不存在），然后根据这个观察结果采用相应动作（创建文件X），但其实可能在观测出结果与做出动作之间的时间端，其他线程创建了文件X，这种操作会导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。最典型的例子就是单例模式中的“懒汉式”实现。

​	另一种竞态条件类型是“读取-修改-写入”操作，例如递增运算。从JMM的角度看递增运算，就会发现其在并发环境下会存在竞态条件的问题。

​	要避免竞态条件，就必须在某个线程修改变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作之前或之后读取和修改状态，而不是在修改状态的过程中。例如给操作增加原子性（如原子类）、加锁等。

## 加锁机制

​	Java提供了一种内置的锁机制来支持原子性：**同步代码块（Synchronized Block）**。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字`Synchronized`来修饰的方法就是一种横跨整个方法体的同步代码块[^注1.2.1]，其中该同步代码块的锁就是方法调用所在的对象。静态的`Synchronized`方法以 `Class`对象作为锁。

​	每个Java对象都可以用作实现同步的锁，在对象头中的`Mark Word`设置锁标志，使得对象成为一种**互斥体**，意味着最多只有一个线程能持有。在并发环境下，只有一个线程执行意味着其他线程必须等待，也就导致性能降低。

​	同步代码块通过锁的保护，使得整个同步代码块具有原子性，成为一组不可分割的执行单元。

​	一个锁应当具备可重入性，可重入性是指某个线程试图获得一个已经由它自己持有的锁时必定成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”[^注1.2.2]。重入的实现方式是通过一个计数器记录获取该锁的次数，计数器值为0时，锁就被释放。

​	如果锁不具备重入性，线程将可能发生死锁的情况，如下代码就会产生死锁（假设锁不具备重入性）：

```java
public class Widger{
    public synchronized void doSomething() {
        ...
    }
    
    public class LoggingWidget extands Widget {
        public synchronized void doSomething() {
            super.doSomething();
        }
    }
}
```

> **使用锁保护状态：**
>
> ​	在并发编程中，对于能够修改同一状态（例如一个或多个变量的组合）的行为都应该使用同一个锁进行加锁，否则还是会存在竞态条件的问题而出现不正确的结果。

[^注1.2.1]:同步方法和同步代码块实现不同，前者是设置标志位，后者是通过添加字节码。
[^注1.2.2]:这与pthread（POSIX线程）互斥体的默认加锁行为不同，pthread互斥体的获取操作是以“调用”为粒度的。

## 性能考虑

​	在并发编程过程中，使用`synchronized`关键字应当考虑到并发性能的问题，不能一昧地追求线程安全。所以在设计一个同步方法或同步类时，应将共享代码段与非共享代码段区分开，方便开发人员对哪些代码段进行同步。

​	在使用加锁机制时，应当根据代码块的功能以及执行该代码块所需时间来判断是否应该加锁。例如过长时间持有锁就会导致系统性能降低的问题。

​	总的来说，使用加锁机制时应注意同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性、简单性和性能（并发性）。

# 对象的共享

​	在Java内存模型中，对于一个变量（泛指可以修改的数据）的读取和写入是通过6个原子操作[^注2.1]进行的。并且每个线程都有自己的**工作内存（用于存放变量副本）**，即线程与**主内存（变量真正存放的区域）**还存在一个类似缓冲区的区域。

​	当线程A对一个共享变量进行修改后，可能不会立即将修改后的值同步到主内存中，所以该变量在同一时间点上，在工作内存的值和在主内存的值就会存在不一致的情况。此时如果线程B读取该变量，它是“看不见”线程A所做的修改操作的。

[^注2.1]:6个原子操作为：read、load、use、assign、store、write，具体作用请自行搜索

## 可见性

​	**可见性**是指一个线程对变量的修改动作是能够被其他线程知道的。一个动作具有可见性，也就不会出现**失效数据**[^注2.1.1]的问题。

​	实现可见性最简单的方法就是对共享的变量进行**加锁**。当对一个变量的访问是互斥同步时，对该变量的修改就会同步写入主内存中，也就不会有不可见的问题发生。

​	Java还提供了一种稍弱的同步机制，即 `volatile` 变量，用来确保将变量的修改操作通知到其他线程。`volatile`关键字能实现可见性的关键在于**某线程对变量进行修改操作后，必须紧接着写入主内存。同样，对变量进行读取操作，也必须从主内存中读取**。但`volatile`不会阻塞线程，是一种较弱的同步机制，不应过度依赖它所提供的可见性。还有一点值得注意，`volatile`不提供原子性，对于 **count++** 递增操作是无法保证正确性的。

[^注2.1.1]:失效数据是指读取到的数据是旧数据，对于需要最新数据的线程来说是无用且错误的

## 发布与逸出

​	**发布**一个对象是指，**使对象能够在当前作用于之外的代码中使用**。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。

​	**逸出**与发布类似，**逸出**是发布的贬义表达，指的是**当某个不应该发布的对象被发布的情况**。

​	发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。在发布对象时，如果要确保线程安全，则可能需要同步。

​	下面列出发布对象的例子：

```java
public static Set<Secret> knownSecrets; 

public void initialize() {
	knownSecrets = new HashSet<Secrete>(); 
    // 将对象的引用保存在一个公有的静态变量中。
    // 并且Secret对象也被间接发布，因为任何代码都可以遍历这个集合。
}
```

​	发布也存在传递性，当一个已经被发布的对象通过非私有的变量引用和方法调用到其他对象，那么这些对象也都会被发布。

​	在发布一个内部类的实例时，会隐式地发布外部类实例本身，因为内部类的实例中包含了对外部类实例的隐含引用。如下：

```java
public class ThisEscape {
	public ThisEscape(EventSource source) {
		source.registerListener(
			new EventListener() { // new前面隐式含有 this.
				public void onEvent(Event e) {
					doSomething(e);
				}
		});
	}
}
```

### 关于构造过程中使this引用逸出的情况等待研究————



## 线程封闭

​	当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据（虽是废话，但却是一种方法）。如果仅在单线程内访问数据，就不需要同步。这种技术被成为**线程封闭**，它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法就自动实现线程安全性，即使被封闭的对象本身不是线程安全的。

​	线程封闭技术典型例子就是 **JDBC**的 **Connection**对象。在典型的服务器应用程序中，线程从连接池中获得一个 **Connection**对象，并且用该对象来处理请求，使用完后再将对象返还给连接池。由于大多数请求（例如Servlet请求等）都是单线程采用同步的方式来管理，并且在 **Connection**对象返回之前，连接池不会再将它分配给其他线程，因此，这种连接管理模式在处理请求时隐含地将 **Connection**对象封闭在线程中。

​	Java无法强制将对象封闭在某个线程中，但提供了一些机制来帮助维持线程封闭性，例如局部变量和**ThreadLocal**类。但仍然需要确保对象不会从线程逸出。

### Ad-hoc线程封闭

​	Ad-hoc线程封闭是指，**维护线程封闭性的职责完全有程序实现来承担**。（说白了就是程序员在编写程序时的“自我幻觉”）

​	可见这种类型的线程封闭是非常脆弱的，并没有使用局部变量或可见性修饰符等语言特性将对象封闭到目标线程，完全靠臆想，是一种乌托邦式的幻想。

### 栈封闭

​	栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭（也被称为线程内部使用或者线程局部使用，不要与核心类库中的**TreadLocal**混淆）比Ad-hoc线程封闭更易于维护，也更加健壮。

​	**个人总结**：栈封闭其实就是通过局部变量的特性来实现线程封闭。即使多个线程访问对象的同一个方法，方法内部的局部变量也会拷贝到每个线程的栈中，只有当前线程才能访问。此时就需要注意该局部变量（基本类型永不逸出，因为没有方法获取基本类型的引用）会不会发生逸出。

### TreadLocal类

​	**TreadLocal**类能使线程中的某个值与保存值的对象（TreadLocal对象，也可以说是线程）关联起来。**TreadLocal**提供了**get/set**等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此**get**总是返回由当前执行线程在调用**set**时设置的最新值。

​	**TreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享**。例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个**Connection**对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存在**TreadLocal**对象中，每个线程都会有属于自己的连接，如下代码所示：

```java
private static TreadLocal<Connection> connectionHolder = 
    new TreadLocal<Connection>(){
    	// 重写TreadLocal中的初始化值方法
    	public Connection initialValue(){
            return DriverManager.getConnection(DB_URL);
		}
	};

public static Connection getConnection(){
    // 使用TreadLocal的get接口
    return connectionHolder.get();
}
```

​	当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。

​	当某个线程初次调用 **TreadLocal.get方法**时，就会调用 **initialValue方法** 来获取初始值。所以一般开发人员需要重写 **initialValue方法** 完成初始化工作。

​	TreadLocal变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。

## 不变性

​	同步问题也可以通过实现不变性解决。使用不可变对象（也就相当于一个常量对象），所有并发产生的问题也就自然消失了。竞态条件、失效数据、数据不一致等问题出现都是因为多个线程同时访问**可变**状态。

> 再次强调不可变对象一定是线程安全的！

​	当某个对象在被创建后其状态就不能被修改，那么这个对象就成为不可变对象。虽然在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但**不可变性并不等于将对象中所有的域都声明为final类型**，即使对象中所有的域都是fianl类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。

​	当满足以下条件时，对象才是不可变的：

- 对象创建以后其状态就不能修改；
- 对象的所有域都是final类型[^注2.4.1]（对于final类型是可变对象的引用，可以通过限制修改方法实现将该引用成为不可变的引用）；
- 对象是正确创建的（对象创建期间，this引用没有逸出）；



​	关键字`final`用于构造不可变性对象。`final`**类型的域是不能修改**的（但如果`final`域所引用的对象是可变的，那么这些被引用的对象可以修改的）。在 Java内存模型中，`final`域还有这特殊的语义。`final`域能够确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

​	即使对象是可变的，通过将对象的某些域声明为`final`类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。仅包含一个或两个可变状态的“基本不可变”对象仍然比包含多个可变状态的对象简单。

> **Tip**：
>
> ​	与“除非需要更高的可见性，否则应将所有的域都声明为私有域”一般，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。



# ——————待研究——————

使用`volatile`关键字修饰一个不可变对象时，可以保证线程安全。以如下代码为例：

```java
// 不可变类
class Cache {
	private final Integer number;
	private final Integer[] numbers;
	
	public Cache(Integer num, Integer[] nums) {
		number = num;
		numbers = Arrays.copyOf(nums, nums.length); // 这里使用copyOf方法是因为数组也是对象
	}
}

class VolatileCache {
	private volatile Cache cache = new Cache(null, null);
    
    public void method() {
        Integer number = compute(); // 通过compute方法得出一个整数
        Integer[] numbers = compute(number); // 得到一个新的Integer[]
        doSomething();
        cache = new Cache(number, numbers); // 更新cache
	}
}
```

​	在 类**VolatileCache** 中使用 `volatile` 修饰不可变类**Cache** 的对象，当一个线程更新**cache**引用时，其他线程就会立即看到新的**cache**引用，但其他线程的原本的**cache**引用并未被改变。这样就能保证每个线程中的**cache**引用不被其他线程修改，但能看到最新值。

**个人总结**：不可变对象主要在于创建后状态不可修改，在设计一个不可变类时就需要注意行为不能引起状态的改变。

[^注2.4.1]:从技术上看，不可变对象并不需要将其所有的域都声明为final类型，例如String就是如此，其hash值并未声明为final类型，不过关于hash值的调用总是返回相同的结果。

# ————————————————

# 参考资料

《Java Concurrency in Practiee》（中文名：《Java并发编程实战》） —— Brian Goetz 等著