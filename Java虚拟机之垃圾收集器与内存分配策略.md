# 垃圾收集器与内存分配策略

# 概述

​	垃圾收集技术源自在1960年诞生于麻省理工学院的Lisp，这是第一门开始使用内存动态分配和垃圾收集技术的语言。

​	当Lisp还在胚胎时期时，其作者John McCarthy就思考过垃圾收集需要完成的三件事情：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？



​	在虚拟机的运行时数据区域中，虚拟机栈、虚拟机栈、本地方法栈这三个区域随线程而生，随线程而亡。虚拟机栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。

​	而 Java堆和方法区这两个区域则有着明显的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。

# 回收对象判断

​	垃圾收集器在对堆中对象进行回收前，第一件事情就是要确定哪些对象还“存活”着，哪些已经“死亡”（即不可能再被任何途径使用的对象）。 

## 引用计数算法

​	引用计数算法（Reference Counting）在对象中添加一个引用计数器，每当该对象被引用时，计数器值就加一；当引用失效时，计算器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

​	引用计数算法虽然占用一些额外的内存空间来进行计算，但原理简单，判定效率高，大多数情况下是不错的算法。但是在 Java领域，至少主流的 Java虚拟机都没有选用该算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况需要判断，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数器算法就很难解决对象之间的相互循环引用的问题。

​	如下对象相互循环引用的例子：

```java
public class ReferenceCountingGC {
    
	public Object instance = null;
    
	private static final int _1MB = 1024 * 1024;
    
	/**
	* 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
	*/
	private byte[] bigSize = new byte[2 * _1MB];
	public static void testGC() {
		ReferenceCountingGC objA = new ReferenceCountingGC();
		ReferenceCountingGC objB = new ReferenceCountingGC();
		objA.instance = objB;
		objB.instance = objA;
		objA = null;
		objB = null;
		// 假设在这行发生GC，objA和objB是否能被回收？
		System.gc();
	}
}
```

## 可达性分析算法